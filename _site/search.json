[
  {
    "objectID": "blog/keyboard/index.html",
    "href": "blog/keyboard/index.html",
    "title": "You’re just my type! A beginner’s guide to building a custom mechanical keyboard",
    "section": "",
    "text": "This blog post details a DIY project I did last summer – building a mechanical keyboard. I’m no expert, but I enjoyed the process of building the keyboard so much that I thought I would briefly walk through the steps and share helpful resources. Even if you have no interest in building your own, I hope it encourages you to learn something new that you may have initially felt intimidated by!"
  },
  {
    "objectID": "blog/keyboard/index.html#case",
    "href": "blog/keyboard/index.html#case",
    "title": "You’re just my type! A beginner’s guide to building a custom mechanical keyboard",
    "section": "Case",
    "text": "Case\nThe case is the outside of your keyboard. The size of the case you choose will limit how many keys you can have on your keyboard. Case sizes are described in percentages, i.e. 100%, 80%, 75%, 60%, 40%, which corresponds to how many keys fit on the board."
  },
  {
    "objectID": "blog/keyboard/index.html#pcb",
    "href": "blog/keyboard/index.html#pcb",
    "title": "You’re just my type! A beginner’s guide to building a custom mechanical keyboard",
    "section": "PCB",
    "text": "PCB\nThe Printed Circuit Board (PCB) is the electronic circuitry of your keyboard. You will need to choose a PCB that fits into whatever size case you’ve picked. One option with a PCB is whether it has RGB underglow on it, which means it has tiny lights on it that you can program to display different colors. If you want these lights to show, you should find a case and/or key caps with some aspect of transparency.\nAnother option for the PCB is whether you attach the keys via “hot swap” or “soldering”. If you choose hot swap, you just click the keys into place. However, most PCBs require you to solder the key switches (discussed below) to the circuitry on the board."
  },
  {
    "objectID": "blog/keyboard/index.html#keyboard-plate",
    "href": "blog/keyboard/index.html#keyboard-plate",
    "title": "You’re just my type! A beginner’s guide to building a custom mechanical keyboard",
    "section": "Keyboard plate",
    "text": "Keyboard plate\nKeyboard plates are what you put on top of PCBs to hold your keys in place. You can choose from aluminum, brass, or steel. If you’re feeling overwhelmed, this isn’t something you should stress about. You can barely see it below the keys, so color doesn’t matter much, and the differences in sound/material from the material seem minimal to me. You should make sure to get one that matches the layout of the keys that you want, though."
  },
  {
    "objectID": "blog/keyboard/index.html#key-switches",
    "href": "blog/keyboard/index.html#key-switches",
    "title": "You’re just my type! A beginner’s guide to building a custom mechanical keyboard",
    "section": "Key switches",
    "text": "Key switches\nThis is a fun choice! Key switches are what go below the keys to provide the majority of sound and feel. You can choose from many different brands, e.g. Cherry MX or Gateron, and types of switch feels, e.g. tactile, linear, clicky. I won’t go into all the differences here, but you should know that switch colors correspond to certain sounds/feels. The color of the switch won’t be seen unless you have translucent key caps. I discovered the world of typing test videos while I was picking out key switches."
  },
  {
    "objectID": "blog/keyboard/index.html#key-stabilizers",
    "href": "blog/keyboard/index.html#key-stabilizers",
    "title": "You’re just my type! A beginner’s guide to building a custom mechanical keyboard",
    "section": "Key stabilizers",
    "text": "Key stabilizers\nKey stabilizers are necessary but a bit boring. They go beneath the wider keys like space bar and shift to help distribute the weight of your finger to press the button. It is common to lubricate the key stabilizers before you install them so that these keys are easier to press."
  },
  {
    "objectID": "blog/keyboard/index.html#key-caps",
    "href": "blog/keyboard/index.html#key-caps",
    "title": "You’re just my type! A beginner’s guide to building a custom mechanical keyboard",
    "section": "Key caps",
    "text": "Key caps\nKey caps are, in my opinion, the most exciting part! They go on top of the switches and are the most visible part of the keyboard. You can choose the material and colors, and either buy as a set or pick out unique custom keycaps."
  },
  {
    "objectID": "blog/keyboard/index.html#soldering-equipment",
    "href": "blog/keyboard/index.html#soldering-equipment",
    "title": "You’re just my type! A beginner’s guide to building a custom mechanical keyboard",
    "section": "Soldering equipment",
    "text": "Soldering equipment\nUnless you get a hot swap PCB, you’ll need a soldering iron, solder wire, something to remove excess solder (i.e. solder wick or sucker)."
  },
  {
    "objectID": "blog/keyboard/index.html#test-your-pcb",
    "href": "blog/keyboard/index.html#test-your-pcb",
    "title": "You’re just my type! A beginner’s guide to building a custom mechanical keyboard",
    "section": "1. Test your PCB",
    "text": "1. Test your PCB\nFirst you’ll want to download a keyboard programming app like VIA, plug your keyboard into your computer, take a pair of tweezers, and test each point of key circuitry on your PCB plate."
  },
  {
    "objectID": "blog/keyboard/index.html#lubricate-the-stabilizers",
    "href": "blog/keyboard/index.html#lubricate-the-stabilizers",
    "title": "You’re just my type! A beginner’s guide to building a custom mechanical keyboard",
    "section": "2. Lubricate the stabilizers",
    "text": "2. Lubricate the stabilizers\nIf your PCB plate is working properly, go ahead and add lubricant and put together your stabilizers. I found the whole process a bit tricky, but Youtube helped a lot. There are special lubricants made for keyboards, but I was impatient and used silicone lubricant that I already had."
  },
  {
    "objectID": "blog/keyboard/index.html#place-your-stabilizers-on-the-pcb",
    "href": "blog/keyboard/index.html#place-your-stabilizers-on-the-pcb",
    "title": "You’re just my type! A beginner’s guide to building a custom mechanical keyboard",
    "section": "3. Place your stabilizers on the PCB",
    "text": "3. Place your stabilizers on the PCB\nTime to click the stabilizers into place! You can put the respective keycaps on (space bar, shift, backspace, etc.) and make sure you like the feel at this point."
  },
  {
    "objectID": "blog/keyboard/index.html#add-the-plate-and-click-the-key-switches-into-the-pcb",
    "href": "blog/keyboard/index.html#add-the-plate-and-click-the-key-switches-into-the-pcb",
    "title": "You’re just my type! A beginner’s guide to building a custom mechanical keyboard",
    "section": "4. Add the plate and click the key switches into the PCB",
    "text": "4. Add the plate and click the key switches into the PCB\nYou can now overlay your plate on the PCB and start clicking each key switch’s metal prongs into the small holes on the PCB. You should feel a click when it locks into place, and the switches should not fall out if you flip the board over."
  },
  {
    "objectID": "blog/keyboard/index.html#soldering",
    "href": "blog/keyboard/index.html#soldering",
    "title": "You’re just my type! A beginner’s guide to building a custom mechanical keyboard",
    "section": "5. Soldering",
    "text": "5. Soldering\nThis was hands-down my favorite part of the entire process. Soldering (pronounced saw-der-ing) is SO much fun. There’s a ton of videos online about it, and you can buy a kit to practice if you want, but honestly I just went for it. You basically melt a piece of metal (solder) and then place the soldering iron right next to the key switch prongs and PCB ring of metal to create an electrical conduction.\n\n\n\nOne important note with soldering is that you should wait a day and retest your keys to make sure the conduction stayed. I had an issue where I would successfully test the keys about five minutes after soldering, but the next day the same keys would no longer work. I finally realized this was because I was soldering outside on a summer night (to avoid the fumes). As the sun went down, my soldering iron was no longer as hot as it said it was (~400° Fahrenheit) because the wind/outside air was cooling it down.\nThis is what my final soldered PCB and switches looked like. Each of the keys has two small mounds of solder creating an electrical conduction between the switch and the PCB. These look like small silver balls."
  },
  {
    "objectID": "blog/keyboard/index.html#stack-and-screw",
    "href": "blog/keyboard/index.html#stack-and-screw",
    "title": "You’re just my type! A beginner’s guide to building a custom mechanical keyboard",
    "section": "6. Stack and screw",
    "text": "6. Stack and screw\nOnce all your keys’ electrical connections work, you can add your key caps. Finally, stack all the pieces together (case, foam plate, plate/PCB/switches/keys) and tighten the necessary screws."
  },
  {
    "objectID": "blog/keyboard/index.html#type-away",
    "href": "blog/keyboard/index.html#type-away",
    "title": "You’re just my type! A beginner’s guide to building a custom mechanical keyboard",
    "section": "7. Type away",
    "text": "7. Type away\nEnjoy the click-clack of your brand new custom mechanical keyboard!"
  },
  {
    "objectID": "blog/trt-timelines/trt-timelines.html",
    "href": "blog/trt-timelines/trt-timelines.html",
    "title": "Patient Treatment Timelines for Longitudinal Survival Data",
    "section": "",
    "text": "A ggplot code walkthrough for making treatment timelines or “swimmer plots” for longitudinal time-to-event data on 1) a categorical covariate and 2) a continuous covariate organized by missingness frequency.\n\nNovember 3, 2019.\nI am a biostatistician at a research university, and I often find myself working with longitudinal survival data. As with any data analysis, I need to examine the quality of my data before deciding which statistical methods to implement.\nThis post contains reproducible examples for how I prefer to visually explore survival data containing longitudinal exposures or covariates. I create a “treatment timeline” for each patient, and the end product looks something like this:\n\n\n\nEach line represents one patient, and each square represents a measurement at a specified point. I find these graphs useful to look for patterns or discrepancies in follow up times, treatment, and missingness. They also allow me to verify that my coding is correct as I move through different data manipulations for my analyses.\nFor the following examples I generate longitudinal survival data sets. I skip over how I made this data because it’s not the focus of this post, but if you have questions about the data generation please let me know. In general, I am trying to work from the point in a survival data analysis where you’ve already calculated each individual’s time to event.\n\nExample 1: Binary Treatment\nTo make these charts, my first step is to load the package tidyverse, since I use functions from dplyr, tidyr, forcats, and ggplot2.\nlibrary(tidyverse)\nHere is the data generation code. If you’re interested in how I made it, you can check the comments, but if not, I recommend just copying and pasting into your R console to try the plotting code.\nset.seed(7)\nn <- 50 # The data sets I make these visualizations for are typically 100-500 patients in size, but for space purposes I'll set my n to only 50.\ndat <- \n  tibble(.rows = n) %>%  # empty data frame / tibble with n rows\n  mutate(pt_id = factor(row_number()),  # patient ids are 1-n\n         pt_trt_prob = runif(n,0,1), # randomly generate a treatment probability for each patient so we can see patterns\n         months_followup = round(runif(n, 0, 20)), # randomly generate length of time in the study\n         death = rbinom(n, 1, .5)) %>% # death randomly occurs at any time point. Obviously an unrealistic assumption. :)\n  group_by(pt_id) %>%   # group by patient so we can do more data manipulation\n  complete(months_followup = full_seq(0:max(months_followup), 1)) %>% # add i^n all the months patients are in the study\n  fill(pt_trt_prob, .direction = \"up\") %>% # fill in the treatment probability I made earlier so I can use this to add treatment for every time point\n  ungroup() %>% # no longer need patients grouped\n  mutate(trt = factor(rbinom(row_number(), 1, pt_trt_prob^2)),  # fill in treatment for everyone based on their treatment probability\n         death = replace_na(death, 0)) %>%  # also fill in death\n  select(pt_id, months_followup, trt, death) # remove leftover columns from data generation\nLet’s look at the data. It’s in “long” format with patient ID’s repeating for each month_followup they were in my (fake) study. At every month, we know whether or not they were on the treatment, and whether they died at that time point. This first example does not contain any missingness.\nknitr::kable(head(dat))\n\n\n\n\npt_id\nmonths_followup\ntrt\ndeath\n\n\n\n\n1\n0\n1\n0\n\n\n1\n1\n1\n0\n\n\n1\n2\n1\n0\n\n\n1\n3\n1\n0\n\n\n1\n4\n1\n0\n\n\n1\n5\n1\n0\n\n\n\n\nWe can now plot our data in a very basic way. We really only need to specify in the aesthetics that the x-axis is time, the y-axis is subject IDs, the color should correspond to treatment, and our lines should be grouped together by subject. Don’t forget that last one! Then we can say we want geom_line to make a base timeline for each subject, and the points on the timeline should be squares (shape = 15 in the geom_point mapping function).\nEt voilà! A cute patient treatment timeline.\ndat %>%\n  ggplot(aes(x = months_followup, y = pt_id, group = pt_id, col = trt)) +\n  geom_line()  + \n  geom_point(shape = 15)\n\n\n\nOkay, it’s not that cute. But that little bit of code is really the core of the plot! If you want to add markers of death (or any other event) and rearrange by length of follow up time it just takes a little bit of extra data manipulation and one additional line of ggplot2 code.\ndat %>%\n  group_by(pt_id) %>%\n  # make a new column with all patients last follow up visit\n  mutate(last_month_followup = max(months_followup), \n         # new variable for month that patients died, if they died\n         month_death = case_when(death == 1 ~ last_month_followup, TRUE ~ NA_real_)) %>%\n         # reorder pt id by last month of follow up (highest to lowest)\n         # without fct_rev, chart is arranged in opposite direction (lowest to highest)\n  ungroup() %>%\n  mutate(pt_id = fct_rev(fct_reorder(pt_id, last_month_followup))) %>%\n  ggplot(aes(x = months_followup, y = pt_id, group = pt_id, col = trt)) +\n  geom_line()  + \n  geom_point(shape = 15) + \n  # add in a new mapping layer of points that correspond to death\n  geom_point(aes(x = month_death, y = pt_id), col = \"black\", shape = 4) \nWarning: Removed 515 rows containing missing values (geom_point).\n\n\n\nDon’t worry about the warning for removing missing values – it’s because we have NAs at most months for our month_death, so geom_point doesn’t know where to put an ‘x’ marker.\nFinally, let’s work on making the plot a bit nicer to look at:\ndat %>%\n  group_by(pt_id) %>%\n  mutate(last_month_followup = max(months_followup), \n         month_death = case_when(death == 1 ~ last_month_followup, TRUE ~ NA_real_)) %>%\n  ungroup() %>%\n  mutate(pt_id = fct_rev(fct_reorder(pt_id, last_month_followup)),\n         # make the treatment variable labels nicer\n         trt = factor(trt, levels=0:1, labels=c(\"No\",\"Yes\"))) %>%\n  ggplot(aes(x = months_followup, y = pt_id, group = pt_id, col = trt)) +\n  geom_line()  + \n  geom_point(shape = 15) + \n  geom_point(aes(x = month_death, y = pt_id), col = \"black\", shape = 4) +\n  theme_bw() +\n  labs(x = \"Months of Follow-Up\", y = \"Patient ID\", col = \"Treatment\",\n       title = \"Patient Treatment Timeline\",\n       subtitle = \"x indicates month of patient death\") +\n  # edit legend box and make patient ids small\n  theme(axis.text.y = element_text(size=6),\n        legend.position = c(.6, .9), legend.direction = \"horizontal\",\n        legend.background = element_rect(linetype=\"solid\", colour =\"black\")) +\n  # remove extra space around timeline\n  scale_x_continuous(expand=c(0.01,0.01)) +\n  # set the color of the lines and points\n  scale_color_manual(values=c(\"dodgerblue\",\"firebrick1\"))\nWarning: Removed 515 rows containing missing values (geom_point).\n\n\n\nI have never made one of these plots for publication, so I don’t mind that the subtitle contains legend information. If you wanted to have the month_death markers in a legend, you could change:\ngeom_point(aes(x = month_death, y = pt_id), col = \"black\", shape = 4)\nto:\ngeom_point(aes(x = month_death, y = pt_id, shape = month_death), col = \"black\")\n\n\nExample 2: Continuous Covariate with Missingness\nWe can follow the very same steps for making a timeline for a continuous variable.\nAgain, here is the data generation code so you can make these plots yourself:\ndat_cc <- \n  tibble(.rows = n) %>%\n  mutate(pt_id = row_number(),\n         months_followup = round(runif(n, 0, 12)), # random months of follow up\n         pt_cov_mean = runif(n, 80, 150), # random mean of a patient's covariate measures\n         death = rbinom(n, 1, 0.5)) %>% # random death\n  group_by(pt_id) %>%\n  complete(months_followup = full_seq(0:max(months_followup), 1)) %>%\n  fill(pt_cov_mean, death, .direction = \"up\") %>%\n  mutate(last_month_followup = max(months_followup),\n         death_date = case_when(death == 1 ~ last_month_followup, TRUE ~ NA_real_)) %>%\n  ungroup() %>%\n  mutate(cov = rnorm(row_number(), pt_cov_mean, 10))  # everyone's covariates are close to their original mean (use to see patterns later)\nThis time I am incorporating missingness at a patient-level on my simulated covariate measurements to show how we can use the plots to look at potential patterns in missingness.\ndat_cc_samp <- dat_cc %>%\n  mutate(idx = row_number()) %>%\n  sample_frac(.4, weight = pt_cov_mean^3)  %>% # sample 40% of data, with weights for the sample determined by the patient's mean covariate. This would mean patients with a higher mean covariate measure are more likely to have missing data.\n  pull(idx)\n\ndat_cc_miss  <- dat_cc %>%\n  mutate(cov = case_when(row_number() %in% dat_cc_samp ~ NA_real_,\n                         TRUE ~ cov)) %>%\n  select(pt_id, months_followup, cov, death)\nLooking again at the data we’ll be using:\nknitr::kable(head(dat_cc_miss))\n\n\n\n\npt_id\nmonths_followup\ncov\ndeath\n\n\n\n\n1\n0\n91.69544\n0\n\n\n2\n0\nNA\n1\n\n\n2\n1\nNA\n1\n\n\n2\n2\n156.57317\n1\n\n\n2\n3\nNA\n1\n\n\n2\n4\n172.23156\n1\n\n\n\n\nWe can plot the data and see this missingness with gray timeline points and lines:\ndat_cc_miss %>%\n  group_by(pt_id) %>%\n  mutate(last_month_followup = max(months_followup), \n         month_death = case_when(death == 1 ~ last_month_followup, TRUE ~ NA_real_)) %>%\n  ungroup() %>%\n  mutate(pt_id = fct_rev(fct_reorder(factor(pt_id), last_month_followup))) %>%\n  ggplot(aes(x = months_followup, y = pt_id,\n             group = pt_id, col = cov)) +\n  geom_line()  + \n  geom_point(shape = 15) + \n  geom_point(aes(x = month_death, y = pt_id), shape=4, col=\"black\") +\n  theme_bw() +\n  labs(x = \"Months of Follow-Up\", y = \"Patient ID\", col = \"Covariate\",\n       title = \"Patient Timelines: Continuous Covariate\",\n       subtitle = \"x indicates month of patient death, gray indicates missing covariate\") +\n  theme(axis.text.y = element_text(size=6),\n        legend.position = c(.7, .9),\n        legend.direction = \"horizontal\",\n        legend.background = element_rect(linetype=\"solid\", colour =\"black\")) +\n  scale_x_continuous(expand=c(0.01,0.01)) +\n  scale_color_gradient(low=\"dodgerblue\", high=\"firebrick1\", na.value = \"lightgray\",\n                       breaks=c(90, 120, 150, 180)) \nWarning: Removed 143 rows containing missing values (geom_point).\n\n\n\nAlternatively, we could rearrange our timelines by the number of measures we have for each patient’s covariate of interest by making a new column containing the sum(!is.na(cov)) and rearranging our pt_id by that column.\ndat_cc_miss %>%\n  group_by(pt_id) %>%\n  mutate(last_month_followup = max(months_followup),\n         # a column containing how many measures we have for each patient\n         n_measures = sum(!is.na(cov))) %>%\n  ungroup() %>%\n  mutate(\n    # reorder IDs by number of measures we have for each patient\n    pt_id = fct_rev(fct_reorder(factor(pt_id), n_measures)),\n  month_death = case_when(death == 1 ~ last_month_followup, TRUE ~ NA_real_)) %>%\n  ggplot(aes(x = months_followup, y = pt_id,\n             group = pt_id, col = cov)) +\n  geom_line()  + \n  geom_point(shape = 15) + \n  geom_point(aes(x = month_death, y = pt_id), shape=4, col=\"black\") +\n  theme_bw() +\n  labs(x = \"Months of Follow-Up\", y = \"Patient ID\", col = \"Covariate\",\n       title = \"Patient Timelines: Continuous Covariate\",\n       subtitle = \"x indicates month of patient death, gray indicates missing covariate\") +\n  theme(axis.text.y = element_text(size=6),\n        legend.position = c(.7, .9),\n        legend.direction = \"horizontal\",\n        legend.background = element_rect(linetype=\"solid\", colour =\"black\")) +\n  scale_x_continuous(expand=c(0.01,0.01)) +\n  scale_color_gradient(low=\"dodgerblue\",high=\"firebrick1\",na.value = \"lightgray\",\n                       breaks=c(90, 120, 150, 180)) \nWarning: Removed 143 rows containing missing values (geom_point).\n\n\n\nFrom this plot we can start to see that patients with more missing measurements have higher covariate measurements. This becomes clearer if we rearrange patients by their proportion of non-missing measurements.\ndat_cc_miss %>%\n  group_by(pt_id) %>%\n  mutate(last_month_followup = max(months_followup),\n         # the proportion is the total number of measures divided by the total months of followup\n         prop_measures = sum(!is.na(cov))/last_month_followup) %>%\n  ungroup() %>%\n  # reorder IDs by proportion of measures we have for each patient\n  mutate(pt_id = fct_rev(fct_reorder(factor(pt_id), prop_measures)),\n  month_death = case_when(death == 1 ~ last_month_followup, TRUE ~ NA_real_)) %>%\n  ggplot(aes(x = months_followup, y = pt_id,\n             group = pt_id, col = cov)) +\n  geom_line()  + \n  geom_point(shape = 15) + \n  geom_point(aes(x = month_death, y = pt_id), shape=4, col=\"black\") +\n  theme_bw() +\n  labs(x = \"Months of Follow-Up\", y = \"Patient ID\", col = \"Covariate\",\n       title = \"Patient Timelines: Continuous Covariate\",\n       subtitle = \"x indicates month of patient death, gray indicates missing covariate\") +\n  theme(axis.text.y = element_text(size=6), # move legend to the side by removing legend location\n        legend.background = element_rect(linetype=\"solid\", colour =\"black\")) +\n  scale_x_continuous(expand=c(0.01,0.01)) +\n  scale_color_gradient(low=\"dodgerblue\",high=\"firebrick1\",na.value = \"lightgray\",\n                       breaks=c(90, 120, 150, 180)) \nWarning: Removed 143 rows containing missing values (geom_point).\n\n\n\nIf this were my real data, I would follow up with my research collaborators for more information on the missingness mechanism.\nPlease let me know if you have questions or a suggestion for a data set. Happy treatment timeline plotting!\n\n\nSession info\nsessionInfo()\nR version 4.1.3 (2022-03-10) Platform: x86_64-apple-darwin17.0 (64-bit) Running under: macOS Catalina 10.15.7\nMatrix products: default BLAS: /Library/Frameworks/R.framework/Versions/4.1/Resources/lib/libRblas.0.dylib LAPACK: /Library/Frameworks/R.framework/Versions/4.1/Resources/lib/libRlapack.dylib\nlocale: [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\nattached base packages: [1] stats graphics grDevices utils datasets methods base\nother attached packages: [1] forcats_0.5.1 stringr_1.4.1 dplyr_1.0.9 purrr_0.3.4\n[5] readr_2.1.2 tidyr_1.2.0 tibble_3.1.8 ggplot2_3.3.6\n[9] tidyverse_1.3.1\nloaded via a namespace (and not attached): [1] tidyselect_1.1.2 xfun_0.32 haven_2.5.0 colorspace_2.0-3 [5] vctrs_0.4.1 generics_0.1.3 htmltools_0.5.2 yaml_2.3.5\n[9] utf8_1.2.2 rlang_1.0.4 pillar_1.8.1 glue_1.6.2\n[13] withr_2.5.0 DBI_1.1.2 dbplyr_2.1.1 modelr_0.1.8\n[17] readxl_1.4.0 lifecycle_1.0.1 munsell_0.5.0 gtable_0.3.0\n[21] cellranger_1.1.0 rvest_1.0.2 htmlwidgets_1.5.4 evaluate_0.15\n[25] labeling_0.4.2 knitr_1.38 tzdb_0.3.0 fastmap_1.1.0\n[29] cabinets_0.6.0 fansi_1.0.3 highr_0.9 broom_0.8.0\n[33] backports_1.4.1 scales_1.2.1 jsonlite_1.8.0 farver_2.1.1\n[37] fs_1.5.2 gridExtra_2.3 hms_1.1.1 digest_0.6.29\n[41] stringi_1.7.8 grid_4.1.3 cli_3.3.0 tools_4.1.3\n[45] magrittr_2.0.3 crayon_1.5.1 pkgconfig_2.0.3 ellipsis_0.3.2\n[49] xml2_1.3.3 reprex_2.0.1 lubridate_1.8.0 assertthat_0.2.1 [53] rmarkdown_2.13 httr_1.4.2 rstudioapi_0.13 R6_2.5.1\n[57] compiler_4.1.3"
  },
  {
    "objectID": "blog/trt-timelines/multiple-vars.html",
    "href": "blog/trt-timelines/multiple-vars.html",
    "title": "Using ggplot2 to create Treatment Timelines with Multiple Variables",
    "section": "",
    "text": "An R code walkthrough for treatment timelines or “swimmer” plots. These can help visualize treatment or measurement patterns, time-varying covariates, outcomes, and loss to follow-up in longitudinal data settings.\n\nJune 8, 2022.\n\n\n\nThis post walks through code to create a timeline in R using ggplot2. These types of plots can help visualize treatment or measurement patterns, time-varying covariates, outcomes, and loss to follow-up in longitudinal data settings.\nYou can view a corresponding slide deck I made with {flipbookr} for the 2022 R/Medicine [here], or you can skip to the end of this post to just see the code.\n\nBackground\nTreatment timelines, or “swimmer plots”, are a visualization technique I find useful in exploring longitudinal data structures. A few years ago I shared how I make treatment timelines for a single treatment (categorical or continuous) in the post Patient Treatment Timelines for Longitudinal Survival Data.\nSometimes when I share these plots with collaborators, they ask me to add additional variables to the timelines. This post shows how to do that.\nI’ll use a toy dataset on hospitalized COVID-19 patients, available to download on this Github repository. It is derived from a dataset from Electronic Health Record data during Spring 2020. This is a time period when there was large variation in provider practice in administering steroids, a type of drug that combats hyper-inflammation. Steroids are usually given to patients which exhibit an inflammatory profile; we will identify this using a threshold for low oxygen levels (severe hypoxia).\nWe will look at the treatment patterns of steroids as it relates to the timing of patients (1) reaching severe hypoxia and (2) being put on a ventilator (intubation). We will also include whether patients died. I used a similar figure in a recent manuscript on this topic, if you’re interested in learning more!\n\n\nExploring the data\nThe data set is in long format with one row per patient. Let’s first load the data set and libraries we’ll need, then look at the first 20 rows:\n# install.packages(c(\"tidyverse\",\"gt\",\"RCurl\",\"rmarkdown\"))\nlibrary(tidyverse)\nlibrary(gt)\nlibrary(rmarkdown)\n\ndat_long <- read_csv(\"https://raw.githubusercontent.com/kathoffman/steroids-trial-emulation/main/data/dat_trt_timeline.csv\", col_types = list(id  = \"c\", steroids = \"c\", death = \"c\", severe = \"c\"))\nIf we look at the first patient (id = 797), we can see they were in the hospital for 17 days, never intubated, never receive steroids, and ultimately die (death is 1 on the last day).\nhead(dat_long) |>\n  paged_table()\n\n\n\n  \n\n\nWe can plot all patients’ hospital length of stay, colored by intubation status using ggplot2’s geom_line():\ndat_long |>\n  ggplot(aes(x=day, y=id, col = intubation_status, group=id)) +\n  geom_line() +\n  theme_bw()\n\n\n\nWe can add our steroids column to the plot by adding a point designating whether steroids exposure was 1 (yes) or 0 (no) that day. We can see this results in points of two different colors on the lines of our plot. This can work just fine! …unless you want to add another variable to the timeline.\ndat_long |>\n  ggplot(aes(x=day, y=id, col = intubation_status, group=id)) +\n  geom_point(aes(day, id, col = steroids)) +\n  geom_line() +\n  theme_bw() \n\n\n\n\n\nModify the data\nWe could edit the colors of the dots we don’t want so that they’re transparent (using NA), but when you have other non-mutually exclusive dots you want to show, it’s simpler to just edit the data instead. So, we will now edit our data so that our three binary columns are turned into three *_this_day column, where:\n\nThe value is NA if the observation did not experience that exposure/outcome that day (remember each day is a new row)\nThe value is the day if the observation did experience the exposure/outcome. This is to make our x axis easy to specify in ggplot2.\n\ndat_swim <-\n  dat_long |>\n  mutate(severe_this_day = case_when(severe == 1 ~ day),\n         steroids_this_day = case_when(steroids == 1 ~ day),\n         death_this_day = case_when(death == 1 ~ day))\nWhile we’re at it, let’s modify the patient’s IDs so that we can rearrange our plot by length of each individual’s timeline. To do this, we will reorder the factored id variable by a new variable max_day, or the length of time that patients are in the study.\ndat_swim <- \n  dat_swim |>\n  group_by(id) |>\n  mutate(max_day = max(day)) |>\n  ungroup() |>\n  mutate(id = fct_reorder(factor(id), max_day))\n\nhead(dat_swim) |> paged_table()\n\n\n\n  \n\n\n\n\nBack to plotting\nNow, we can re-plot the steroids and intubation statuses using our new data. This time without all the 0 values for steroids showing.\ndat_swim |> \n  ggplot() +\n  geom_line(aes(x=day, y=id, col = intubation_status, group=id)) +\n  geom_point(aes(x=steroids_this_day, y=id, col=\"Steroids\", shape=\"Steroids\")) +\n  theme_bw()\nWarning: Removed 387 rows containing missing values (geom_point).\n\n\n\nFrom this point on I’ll save the plot as p and just keep adding onto it so you can see the new step.\nWe’ll see why we’re doing this in a second, but in creating this first iteration of p using geom_line() and geom_point(), we also want to set the col to match how we want the marker for steroids to appear in the legend. I’m also going to make minor edits to the size and shape of the point geometry right now, as well as the width of each timeline itself (also using the size argument).\np <- \n  dat_swim |> \n  ggplot() +\n  geom_line(aes(x=day, y=id, col = intubation_status, group=id),\n            size=1.8) +\n  geom_point(aes(x=steroids_this_day, y=id, col=\"Steroids\"), stroke=2, shape=15) +\n  theme_bw()\np\nWarning: Removed 387 rows containing missing values (geom_point).\n\n\n\nLet’s add hypoxia and death to the figure. We’ll use geom_point() again, and again specify legend names for the col and shape arguments, and modify the size and stroke of our point geometries.\np <- p +\n  geom_point(aes(x=severe_this_day, y=id, col=\"Severe hypoxia\"), size=2, stroke=1.5, shape=21) +\n  geom_point(aes(x=death_this_day, y=id, col=\"Death\"), size=2, stroke=1.5, shape=4) \np\nWarning: Removed 387 rows containing missing values (geom_point).\nWarning: Removed 403 rows containing missing values (geom_point).\nWarning: Removed 414 rows containing missing values (geom_point).\n\n\n\nNote that we get warning messages that values with NA are removed. This is fine since we just created all those NAs! I’m going to set my options so that warnings are suppressed for future code outputs to keep this post tidy.\nknitr::opts_chunk$set(message=F, warning=F)\n\n\nModify the colors and shapes\nNext let’s start changing our color and shape scales. We can change colors using scale_color_manual() and and filling in the values argument with a vector where the names of the vector match the names in the col in our geom_point() aesthetics.\nI define my cols in a vector outside the plotting code to keep everything cleaner. Note that the order we’re specifying here will continue throughout the rest of the plotting code!\n# define colors for all geometries with a color argument\ncols <- c(\"Severe hypoxia\" = \"#b24745\", # red\n          \"Intubated\" = \"#483d8b\", # navy\n          \"Not intubated\" = \"#74aaff\", # lighter blue\n          \"Steroids\"=\"#ffd966\", # gold\n          \"Death\" = \"#000000\") # black \nAfter we set values = cols, the name argument is simply the title we want for our legend (I chose “Patient Status”).\np <- p +\n  scale_color_manual(values = cols, name=\"Patient Status\") \np\n\n\n\n\n\nFix the Legend\nYou’ll notice that our legend does not match the changes we made to the shapes, size, or linetype right now. This is because our legend only contains information on the colors, because that’s all we’re mapping to the aesthetics of our geometries right now (in geom_point and geom_line. We can override the color legend aesthetics and still create a plot that shows correct and useful information.\nWe will do this by using the guides() function. We can control each aesthetic here. We will first override the colors legend with the code guide_legend(override.aes = list(...)).\nThis allows us to change the shapes of the color legend by specifying a vector with the shapes, size, and line types we want in the order the labels appear in the legend. If we don’t want a characteristic to appear on the legend, we will use NA.\nI only want to show shapes for certain statuses (severe hypoxia, steroid administration, death), and not the intubation status of a patient, so I’ll set up my shape override vector accordingly. Note that the order in the legend follows the order of my color specification vector (cols).\nshape_override <- c(21, NA, NA, 15, 4) # order matches `cols`:severe, intubation (yes/no), steroids, death\n\np +\n  guides(color = guide_legend(\n                      override.aes = list(\n                          shape = shape_override) # modify the color legend to include shapes\n                      )\n         ) \n\n\n\nTo remove the line through Death, Severe hypoxia, and Steroids in our legend, we can override the aesthetics for linetype with NA’s for those three labels. We will specify the default, linetype=1, for our intubation status color labels.\nWe can additionally override the stroke and size arguments to correspond to our point geometries.\nline_override <- c(NA,1,1,NA,NA) # order matches `cols`:severe, intubation (yes/no), steroids, death\nstroke_override <- c(1.2,1,1,1,1.4) # order matches `cols`:severe, intubation (yes/no), steroids, death\nsize_override <- c(2.5,2.5,2.6,2.5,2) # order matches `cols`:severe, intubation (yes/no), steroids, death\n\np <-\n  p +\n    guides(color = guide_legend(\n                        override.aes = list(\n                                stroke = stroke_override,\n                                shape = shape_override,\n                                linetype = line_override,\n                                size = size_override)\n                                )\n             )\np\n\n\n\nOk, the challenging parts are done! Now we can make some minor aesthetic edits using labs, scale_x_continuous(), and theme(). I won’t go into detail on these edits because they’re fairly self-explanatory, but check out the help files if you’re unsure what these arguments in theme do!\np <- p +\n  labs(x=\"Days since hospitalization\",y=\"Patient\\nnumber\",title=\"Treatment Timeline for N=30 Patients\") +\n  scale_x_continuous(expand=c(0,0)) + # remove extra white space \n  theme(# text=element_text(family=\"Poppins\", size=11),\n        title = element_text(angle = 0, vjust=.5, size=12, face=\"bold\"),\n        axis.title.y = element_text(angle = 0, vjust=.5, size=12, face=\"bold\"),\n        axis.title.x = element_text(size=15, face=\"bold\", vjust=-0.5, hjust=0),\n        axis.text.y = element_text(size=6, hjust=1.5),\n        axis.ticks.y = element_blank(),\n        legend.position = c(0.8, 0.3),\n        legend.title = element_text(colour=\"black\", size=13, face=4),\n        legend.text = element_text(colour=\"black\", size=10),\n        legend.background = element_rect(size=0.5, linetype=\"solid\", colour =\"gray30\"),\n        panel.grid.minor = element_blank(),\n        panel.grid.major.x = element_blank()\n  ) \np\n\n\n\nHope this is helpful! As always let me know if you have any feedback or suggestions. If you’d like to copy-paste the code, here it is:\n\n\nJust the Code\nlibrary(tidyverse)\n\ndat_long <- read_csv(\"https://raw.githubusercontent.com/kathoffman/steroids-trial-emulation/main/data/dat_trt_timeline.csv\", col_types = list(id  = \"c\", steroids = \"c\", death = \"c\", severe = \"c\"))\n\n# define colors for all geometries with a color argument\ncols <- c(\"Severe hypoxia\" = \"#b24745\", # red\n          \"Intubated\" = \"#483d8b\", # navy\n          \"Not intubated\" = \"#74aaff\", # lighter blue\n          \"Steroids\"=\"#ffd966\", # gold\n          \"Death\" = \"#000000\") # black \n\nshape_override <- c(21, NA, NA, 15, 4) # order matches `cols`:severe, intubation (yes/no), steroids, death\nline_override <- c(NA,1,1,NA,NA) # order matches `cols`:severe, intubation (yes/no), steroids, death\nstroke_override <- c(1.2,1,1,1,1.4) # order matches `cols`:severe, intubation (yes/no), steroids, death\nsize_override <- c(2.5,2.5,2.6,2.5,2) # order matches `cols`:severe, intubation (yes/no), steroids, death\n\n# modify swimmer data to 1) only show events if yes 2) have an id ordered by max follow up\ndat_swim <- \n   dat_long |>\n  mutate(severe_this_day = case_when(severe == 1 ~ day),\n         steroids_this_day = case_when(steroids == 1 ~ day),\n         death_this_day = case_when(death == 1 ~ day)) |>\n  group_by(id) |>\n  mutate(max_day = max(day)) |>\n  ungroup() |>\n  mutate(id = fct_reorder(factor(id), max_day))\n\ndat_swim |>\n  ggplot() +\n  geom_line(aes(x=day, y=id, col = intubation_status, group=id),\n            size=1.8) +\n  geom_point(aes(x=steroids_this_day, y=id, col=\"Steroids\"), shape=15, stroke=2) +\n  geom_point(aes(x=severe_this_day, y=id, col=\"Severe hypoxia\"), size=2, stroke=1.5, shape=21) +\n  geom_point(aes(x=death_this_day, y=id, col=\"Death\"), size=2, stroke=1.5, shape=4) +\n  theme_bw() +\n  scale_color_manual(values = cols, name=\"Patient Status\") +\n  guides(color = guide_legend(\n                        override.aes = list(\n                                stroke = stroke_override,\n                                shape = shape_override,\n                                linetype = line_override,\n                                size = size_override)\n                                )\n             )+\n  labs(x=\"Days since hospitalization\",y=\"Patient\\nnumber\",title=\"Treatment Timeline for N=30 Patients\") +\n  scale_x_continuous(expand=c(0,0)) + # remove extra white space \n  theme(# text=element_text(family=\"Poppins\", size=11),\n        title = element_text(angle = 0, vjust=.5, size=12, face=\"bold\"),\n        axis.title.y = element_text(angle = 0, vjust=.5, size=12, face=\"bold\"),\n        axis.title.x = element_text(size=15, face=\"bold\", vjust=-0.5, hjust=0),\n        axis.text.y = element_text(size=6, hjust=1.5),\n        axis.ticks.y = element_blank(),\n        legend.position = c(0.8, 0.3),\n        legend.title = element_text(colour=\"black\", size=13, face=4),\n        legend.text = element_text(colour=\"black\", size=10),\n        legend.background = element_rect(size=0.5, linetype=\"solid\", colour =\"gray30\"),\n        panel.grid.minor = element_blank(),\n        panel.grid.major.x = element_blank()\n  ) \n\n\nSession Info\n\nsessionInfo()\n\nR version 4.1.3 (2022-03-10)\nPlatform: x86_64-apple-darwin17.0 (64-bit)\nRunning under: macOS Catalina 10.15.7\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.1/Resources/lib/libRblas.0.dylib\nLAPACK: /Library/Frameworks/R.framework/Versions/4.1/Resources/lib/libRlapack.dylib\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n [1] rmarkdown_2.13  gt_0.6.0        forcats_0.5.1   stringr_1.4.1  \n [5] dplyr_1.0.9     purrr_0.3.4     readr_2.1.2     tidyr_1.2.0    \n [9] tibble_3.1.8    ggplot2_3.3.6   tidyverse_1.3.1\n\nloaded via a namespace (and not attached):\n [1] lubridate_1.8.0   assertthat_0.2.1  digest_0.6.29     utf8_1.2.2       \n [5] R6_2.5.1          cellranger_1.1.0  backports_1.4.1   reprex_2.0.1     \n [9] evaluate_0.15     httr_1.4.2        pillar_1.8.1      rlang_1.0.4      \n[13] curl_4.3.2        readxl_1.4.0      rstudioapi_0.13   labeling_0.4.2   \n[17] htmlwidgets_1.5.4 bit_4.0.4         munsell_0.5.0     broom_0.8.0      \n[21] compiler_4.1.3    modelr_0.1.8      xfun_0.32         pkgconfig_2.0.3  \n[25] htmltools_0.5.2   tidyselect_1.1.2  fansi_1.0.3       crayon_1.5.1     \n[29] tzdb_0.3.0        dbplyr_2.1.1      withr_2.5.0       cabinets_0.6.0   \n[33] grid_4.1.3        jsonlite_1.8.0    gtable_0.3.0      lifecycle_1.0.1  \n[37] DBI_1.1.2         magrittr_2.0.3    scales_1.2.1      cli_3.3.0        \n[41] stringi_1.7.8     vroom_1.5.7       farver_2.1.1      fs_1.5.2         \n[45] xml2_1.3.3        ellipsis_0.3.2    generics_0.1.3    vctrs_0.4.1      \n[49] tools_4.1.3       bit64_4.0.5       glue_1.6.2        hms_1.1.1        \n[53] parallel_4.1.3    fastmap_1.1.0     yaml_2.3.5        colorspace_2.0-3 \n[57] rvest_1.0.2       knitr_1.38        haven_2.5.0"
  },
  {
    "objectID": "pubs/pubs_methods.html",
    "href": "pubs/pubs_methods.html",
    "title": "Methods",
    "section": "",
    "text": "Statistical and Epidemiological Research Methods Manuscripts and Pre-prints\n\n1. Hoffman KL, Schenck EJ, Satlin MJ, et al. Comparison of a Target Trial Emulation Framework vs Cox Regression to Estimate the Association of Corticosteroids With COVID-19 Mortality. JAMA Network Open. 2022;5(10):e2234425-e2234425. doi:10.1001/jamanetworkopen.2022.34425\n\n\n2. Díaz I, Hoffman KL, Hejazi NS. Causal survival analysis under competing risks using longitudinal modified treatment policies. Published online 2022. doi:10.48550/ARXIV.2202.03513\n\n\n3. Díaz I, Williams N, Hoffman KL, Schenck EJ. Nonparametric Causal Effects Based on Longitudinal Modified Treatment Policies. Journal of the American Statistical Association. Published online September 2021:1-16. doi:10.1080/01621459.2021.1955691"
  },
  {
    "objectID": "pubs/pubs_applications.html",
    "href": "pubs/pubs_applications.html",
    "title": "Clinical Applications",
    "section": "",
    "text": "The majority of my research collaborations to date are with researchers on the Pulmonary and Critical Care Medicine team at Weill Cornell Medicine (WCM). Other long-term research experiences includes applications within neurology (cognitive decline/brain volumes), neuroepigenetics (effects of sugar consumption), canine genomics, and associations with air pollution and kidney disease.\nThis is a selected list of clinical application manuscripts I’ve co-authored. A full list of published manuscripts and papers-under-review is available on my CV.\n*Indicates authors contributed equally to the work.\n\n\n\n\n\n\n\nSelected Clinical Application Publications\n\n1. *Schenck EJ, *Hoffman KL, Oromendia C, et al. A Comparative Analysis of the Respiratory Subscore of the Sequential Organ Failure Assessment Scoring System. Annals of the American Thoracic Society. 2021;18(11):1849-1860. doi:10.1513/AnnalsATS.202004-399OC\n\n\n2. *Gómez-Escobar LG, *Hoffman KL, Choi JJ, et al. Cytokine signatures of end organ injury in COVID-19. Scientific Reports. 2021;11(1):12606. doi:10.1038/s41598-021-91859-z\n\n\n3. Schenck EJ, Hoffman K, Goyal P, et al. Respiratory Mechanics and Gas Exchange in COVID-19–associated Respiratory Failure. Annals of the American Thoracic Society. 2020;17(9):1158-1161. doi:10.1513/AnnalsATS.202005-427RL\n\n\n4. Torres LK, Hoffman KL, Oromendia C, et al. Attributable mortality of acute respiratory distress syndrome: A systematic review, meta-analysis and survival analysis using targeted minimum loss-based estimation. Thorax. 2021;76(12):1176-1185. doi:10.1136/thoraxjnl-2020-215950\n\n\n5. Price DR, Hoffman KL, Oromendia C, et al. Effect of Neutropenic Critical Illness on Development and Prognosis of Acute Respiratory Distress Syndrome. American Journal of Respiratory and Critical Care Medicine. 2021;203(4):504-508. doi:10.1164/rccm.202003-0753LE\n\n\n6. Price DR, Hoffman KL, Sanchez E, Choi AMK, Siempos II. Temporal trends of outcomes of neutropenic patients with ARDS enrolled in therapeutic clinical trials. Intensive Care Medicine. 2021;47(1):122-123. doi:10.1007/s00134-020-06263-4\n\n\n7. Zhang WZ, Hoffman KL, Schiffer KT, et al. Association of plasma mitochondrial DNA with COPD severity and progression in the SPIROMICS cohort. Respiratory Research. 2021;22(1):126. doi:10.1186/s12931-021-01707-x\n\n\n8. Schenck EJ, Hoffman KL, Cusick M, Kabariti J, Sholle ET, Campion TR. Critical carE Database for Advanced Research (CEDAR): An automated method to support intensive care units with electronic health record data. Journal of Biomedical Informatics. 2021;118:103789. doi:10.1016/j.jbi.2021.103789\n\n\n9. Su C, Hoffman KL, Xu Z, et al. Evaluation of Albumin Kinetics in Critically Ill Patients With Coronavirus Disease 2019 Compared to Those With Sepsis-Induced Acute Respiratory Distress Syndrome. Critical Care Explorations. 2021;3(12):e0589. doi:10.1097/CCE.0000000000000589\n\n\n10. Zhang WZ, Rice MC, Hoffman KL, et al. Association of urine mitochondrial DNA with clinical measures of COPD in the SPIROMICS cohort. JCI insight. 2020;5(3):133984. doi:10.1172/jci.insight.133984\n\n\n11. Rahman A, Schelbaum E, Hoffman K, et al. Sex-driven modifiers of Alzheimer risk: A multimodality brain imaging study. Neurology. 2020;95(2):e166-e178. doi:10.1212/WNL.0000000000009781\n\n\n12. *Price DR, *Benedetti E, Hoffman KL, et al. Angiopoietin 2 Is Associated with Vascular Necroptosis Induction in Coronavirus Disease 2019 Acute Respiratory Distress Syndrome. The American Journal of Pathology. 2022;192(7):1001-1015. doi:10.1016/j.ajpath.2022.04.002"
  },
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "Blog",
    "section": "",
    "text": "Order By\n       Default\n         \n          Title\n        \n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\n\n\n\n\n\nAnnotated Forest Plots using ggplot2\n\n\n\n\n\n\nDec 12, 2022\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBuilding Statistical Intuition for Optimal Treatment Rules\n\n\n\n\n\n\nAug 10, 2022\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nYou’re just my type! A beginner’s guide to building a custom mechanical keyboard\n\n\n\n\n\n\nJun 15, 2022\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nUsing ggplot2 to create Treatment Timelines with Multiple Variables\n\n\n\n\n\n\nJun 8, 2022\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAn Illustrated Guide to Modified Treatment Policies, Part 1: Introduction and Motivation\n\n\n\n\n\n\nApr 7, 2022\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHow many ways are there to get a SOFA Score of 10?\n\n\n\n\n\n\nFeb 10, 2022\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBecoming a Biostatistician: FAQs for ‘A Day in the Life of a Biostatistician’\n\n\n\n\n\n\nJan 15, 2021\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAn Illustrated Guide to TMLE, Part III: Properties, Theory, and Learning More\n\n\n\n\n\n\nDec 12, 2020\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAn Illustrated Guide to TMLE, Part II: The Algorithm\n\n\n\n\n\n\nDec 11, 2020\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAn Illustrated Guide to TMLE, Part I: Introduction and Motivation\n\n\n\n\n\n\nDec 10, 2020\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBecome a Superlearner! An Illustrated Guide to Superlearning\n\n\n\n\n\n\nOct 10, 2020\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOn the Sidelines: NYC’s COVID-19 Outbreak from the Eyes of a Pulmonary and Critical Care Team’s Biostatistician\n\n\n\n\n\n\nOct 3, 2020\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCustomizable correlation plots in R\n\n\n\n\n\n\nAug 24, 2020\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nRethinking Conditional and Iterated Expectations as Linear Regression Models\n\n\n\n\n\n\nAug 10, 2020\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSilver Linings: five coding tricks learned during Lockdown\n\n\n\n\n\n\nJul 10, 2020\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPatient Treatment Timelines for Longitudinal Survival Data\n\n\n\n\n\n\nNov 28, 2019\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nStats on Drugs: An Interview with a Pharmaceutical CRO Biostatistician\n\n\n\n\n\n\nOct 6, 2019\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nUsing {sl3} for superlearning\n\n\n\n\n\n\nSep 12, 2019\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTips and Tricks from the 2019 New York R Conference\n\n\n\n\n\n\nJun 10, 2019\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nA Day in the Life of a Biostatistician\n\n\n\n\n\n\nApr 16, 2019\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nA Condensed Key for A Visual Guide to Targeted Maximum Likelihood Estimation (TMLE)\n\n\n\n\n\n\nJan 9, 2019\n\n\n\n\n\n\n\n\nNo matching items"
  }
]