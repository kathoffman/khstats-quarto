{
  "hash": "580e2e82a825a30b0f54032e1c68898b",
  "result": {
    "markdown": "---\ntitle: \"Silver Linings: five coding tricks learned during Lockdown\"\nauthor: \"Katherine Hoffman\"\ndate: 2020-07-10T21:13:14-05:00\ncategories: [\"R\"]\nweight: 30\nimage: /img/covid_fx/gtsummary_tweet.png\ntags: [\"R\",\"Electronic Health Record\",\"COVID-19\",\"data wrangling\",\"tidyverse\",\"tidylog\",\"gtsummary\"]\nmath: true\noutput: \n  blogdown::html_page:\n    toc: false\n    smart: false\n    df_print: \"paged\"\n---\n\n\nTips for using {tidylog}, {gtsummary}, {labelled}, {snakecase}, and more.\n\n<!--more-->\n\n***July 10, 2020.***\n\n\n\n\n\n\n\n\nIn non-coronavirus times, I am the biostatistician for a team of NYC pulmonologists and intensivists. When the pandemic hit NYC in mid-March, I immediately became a <strike>100%</strike> 200% COVID-19 statistician. I received many analysis requests, though not all of them from official investigators:\n\n<blockquote class=\"twitter-tweet\"><p lang=\"en\" dir=\"ltr\">My family recently learned I am the statistician for my hospital‚Äôs pulmonologists and now I get COVID-19 analysis requests from them, too <a href=\"https://t.co/wlHmUaBh6Y\">pic.twitter.com/wlHmUaBh6Y</a></p>&mdash; Kat Hoffman (@rkatlady) <a href=\"https://twitter.com/rkatlady/status/1248746176834306056?ref_src=twsrc%5Etfw\">April 10, 2020</a></blockquote> <script async src=\"https://platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\n\nJokes aside, I was really busy during the Spring 2020 outbreak. While doing work for both hospital operations and rapidly moving COVID-19 academic research, it was especially important to code efficiently and accurately while working with a deluge of Electronic Health Record (EHR) data.\n\nThis post contains my favorite (because they were either the most useful or most used) lines of `R` code for turning very raw-form EHR data into analytical files for descriptive reporting and statistical inference. For the examples, I've created data that is a simplified version of my actual data sets -- just in case you too would like to pretend you are a COVID-19 biostatistician!\n\nThe first data set contains some basic demographic and clinical outcome information for all COVID-19 positive patients who arrived at a hospital. The second data set contains laboratory results for all patients who arrived at the hospital during a certain window of time. In theory, the first data set (`patients`) should be a subset of the second (`labs`).\n\n\n\n```{.r .cell-code}\n# load tidyverse for data creation and set seed for reproducible data\nlibrary(tidyverse)\nset.seed(7)\n\n# data set of basic patient demographics\npatients <-\n  tribble(\n    ~id, ~admit_dt, ~death_or_discharge_dt,\n    ~age, ~sex, ~height, ~weight, ~current_smoker, ~immunosuppressed, \n    100, \"2020-03-21 00:10\", \"2020-05-13 12:10\",\n64, \"Male\", 68, 199, \"Yes\", \"No\", \n    104, \"2020-04-03 12:15\", \"2020-04-29 18:34\",\n25, \"Male\", 72, NA, \"Yes\", \"No\", \n    106, \"2020-03-28 12:22\", \"2020-04-05 19:18\",\n49, \"Female\", 64, 189, \"No\", \"Yes\", \n     107, \"2020-04-10 18:15\",\"2020-04-14 19:12\",\n 88, \"Male\", 62, 111, \"No\", \"Yes\", \n    111, \"2020-04-18 00:49\", \"2020-04-25 19:18\",\n61, \"Female\", 67, 156, \"No\", \"Yes\"\n  ) %>%\n  # set time zone for date time variables\n  mutate_at(vars(ends_with(\"_dt\")), ~as.POSIXct(., tz=\"America/New_York\"))\n\n# generate labs data\nlabs <- map_dfr(100:110, function(x){\n  lab_time <- sample(seq(as.POSIXct(\"2020-03-01 00:00\"), as.POSIXct(\"2020-05-30 00:00\"), by=\"hours\"), runif(1, 50, 200))\n  id <- rep(x, length.out=length(lab_time))\n  lab_name <- sample(c(\"D-Dimer\",\"Platelet Count\",\"C-Reactive Protein\",\"Lactate Dehydrogenase\",\"LYMPHOCYTE PERC\",\"Absolute Lymphocyte Count\"), size = length(lab_time), replace = T)\n  lab_value <- runif(length(lab_time), 100, 1200)\n  lab_value <- ifelse(lab_value > 1000, \">1000\", as.character(round(lab_value)))\n  df <- tibble(id, lab_time, lab_name, lab_value)\n  return(df)\n}) \n```\n\n\n```{.r .cell-code}\npatients\n```\n\n# A tibble: 5 √ó 9\n     id admit_dt            death_or_discharge_dt   age sex    height weight\n  <dbl> <dttm>              <dttm>                <dbl> <chr>   <dbl>  <dbl>\n1   100 2020-03-21 00:10:00 2020-05-13 12:10:00      64 Male       68    199\n2   104 2020-04-03 12:15:00 2020-04-29 18:34:00      25 Male       72     NA\n3   106 2020-03-28 12:22:00 2020-04-05 19:18:00      49 Female     64    189\n4   107 2020-04-10 18:15:00 2020-04-14 19:12:00      88 Male       62    111\n5   111 2020-04-18 00:49:00 2020-04-25 19:18:00      61 Female     67    156\n# ‚Ä¶ with 2 more variables: current_smoker <chr>, immunosuppressed <chr>\n\n```{.r .cell-code}\nlabs\n```\n\n# A tibble: 1,623 √ó 4\n      id lab_time            lab_name                  lab_value\n   <int> <dttm>              <chr>                     <chr>    \n 1   100 2020-05-02 03:00:00 Platelet Count            245      \n 2   100 2020-03-20 20:00:00 C-Reactive Protein        >1000    \n 3   100 2020-05-15 07:00:00 C-Reactive Protein        620      \n 4   100 2020-04-29 00:00:00 Absolute Lymphocyte Count 937      \n 5   100 2020-05-02 08:00:00 Platelet Count            984      \n 6   100 2020-04-13 14:00:00 Absolute Lymphocyte Count 177      \n 7   100 2020-04-30 15:00:00 LYMPHOCYTE PERC           227      \n 8   100 2020-03-24 19:00:00 LYMPHOCYTE PERC           405      \n 9   100 2020-03-12 04:00:00 C-Reactive Protein        878      \n10   100 2020-04-09 11:00:00 Platelet Count            711      \n# ‚Ä¶ with 1,613 more rows\n\n\n\n# 1. `tidylog`\n\nThe first line of `R` code I found most useful was actually just loading an entire package. It sounds crazy, but that's all you have to do! You simply load the package, `tidylog`, after `tidyverse` (or `dplyr` or `tidyr`):\n\n\n\n```{.r .cell-code}\nlibrary(tidylog, warn.conflicts = F)\n```\n\n\nThen, whenever you use one of the previously mentioned packages to wrangle data, `tidylog` will give you super helpful information about what just happened. For example, if you use `mutate` on a column, it will tell you how many new `NA` values were created, if any. It will also remind you which variables you removed, and will give you feedback after you've grouped or ungrouped by a certain variable.\n\n\n\n```{.r .cell-code}\npatients <-\n  patients %>%\n  # compute BMI\n  mutate(bmi = weight / height^2 * 703) %>%\n  # remove the patients height and weight from the data frame\n  select(-height, -weight)\n```\n\n```\nmutate: new variable 'bmi' (double) with 5 unique values and 20% NA\n```\n\n```\nselect: dropped 2 variables (height, weight)\n```\n\n\nIt's especially helpful for joining data, because it will tell you how many rows matched in the right and left hand side of your data. In this example, we can see that about 50% of the lab values in `labs` have a match in patients -- as expected. However, one patient in `patients` does not have any labs in `labs` -- not good! This would be a scenario I would need to follow up with my data source (the Informatics team I work with) to figure out.\n\n\n\n```{.r .cell-code}\npatient_labs <-\n  patients %>%\n  left_join(labs)\n```\n\n```\nJoining, by = \"id\"\nleft_join: added 3 columns (lab_time, lab_name, lab_value)\n> rows only in x 1\n> rows only in y (994)\n> matched rows 629 (includes duplicates)\n> =====\n> rows total 630\n```\n\n```{.r .cell-code}\npatient_labs\n```\n\n# A tibble: 630 √ó 11\n      id admit_dt            death_or_discharge_dt   age sex   current‚Ä¶¬π immun‚Ä¶¬≤\n   <dbl> <dttm>              <dttm>                <dbl> <chr> <chr>     <chr>  \n 1   100 2020-03-21 00:10:00 2020-05-13 12:10:00      64 Male  Yes       No     \n 2   100 2020-03-21 00:10:00 2020-05-13 12:10:00      64 Male  Yes       No     \n 3   100 2020-03-21 00:10:00 2020-05-13 12:10:00      64 Male  Yes       No     \n 4   100 2020-03-21 00:10:00 2020-05-13 12:10:00      64 Male  Yes       No     \n 5   100 2020-03-21 00:10:00 2020-05-13 12:10:00      64 Male  Yes       No     \n 6   100 2020-03-21 00:10:00 2020-05-13 12:10:00      64 Male  Yes       No     \n 7   100 2020-03-21 00:10:00 2020-05-13 12:10:00      64 Male  Yes       No     \n 8   100 2020-03-21 00:10:00 2020-05-13 12:10:00      64 Male  Yes       No     \n 9   100 2020-03-21 00:10:00 2020-05-13 12:10:00      64 Male  Yes       No     \n10   100 2020-03-21 00:10:00 2020-05-13 12:10:00      64 Male  Yes       No     \n# ‚Ä¶ with 620 more rows, 4 more variables: bmi <dbl>, lab_time <dttm>,\n#   lab_name <chr>, lab_value <chr>, and abbreviated variable names\n#   ¬π‚Äãcurrent_smoker, ¬≤‚Äãimmunosuppressed\n\n\n`library(tidylog)` has singlehandedly helped me detect countless errors while working with rapidly changing COVID-19 data from many different sources. My coworker once summed it up perfectly by saying, \"`tidylog` isn't just a package, it's a lifestyle.\"\n\n# 2. `gtsummary::tbl_summary()` + `labelled::add_variable_labels` + `snakecase::to_title_case`\n\n<blockquote class=\"twitter-tweet\"><p lang=\"en\" dir=\"ltr\">efficiently labeling variables: a useful skill if you make a lot of <a href=\"https://twitter.com/hashtag/rstats?src=hash&amp;ref_src=twsrc%5Etfw\">#rstats</a> tablesüë©üèº‚Äçüíª<br><br>feat. labelled, snakecase, stringr &amp; gtsummary üì¶s <a href=\"https://t.co/YmiYZEjVKS\">pic.twitter.com/YmiYZEjVKS</a></p>&mdash; Kat Hoffman (@kat_hoffman_) <a href=\"https://twitter.com/kat_hoffman_/status/1305218425732595713?ref_src=twsrc%5Etfw\">September 13, 2020</a></blockquote> <script async src=\"https://platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\n\n`gtsummary`'s `tbl_summary()` is hands down my favorite function for making summary tables. It is so smooth and flexible to use, and it works seamlessly with the new `gt` package for making tables. You simply input a dataset containing the variables you want to summarize, and, optionally, a grouping variable to stratify those summary statistics by, and you'll immediately have a clean and clear descriptive table!\n\nIn this example, I'll use `tbl_summary()` to summarize the median and IQR or number and percent of all the demographic variables in our `patients` data set. We *could* use this code: the barebones function truly only needs a data set containing the variables of interest, and then `gtsummary` does all the formatting work:\n\n\n\n```{.r .cell-code}\nlibrary(gtsummary)\n```\n\n```\n\nAttaching package: 'gtsummary'\n```\n\n```\nThe following objects are masked from 'package:tidylog':\n\n    mutate, select\n```\n\n\n```{.r .cell-code}\npatients %>% \n  # select vars of interest for tables\n  select(age, sex, bmi, current_smoker, immunosuppressed) %>%\n  tbl_summary(\n    # make sure all numeric variables are reported as continuous\n    type = list(all_numeric() ~ \"continuous\")\n  ) \n```\n\n\nThat'd be fine, but what I *really* found to be useful during the NYC outbreak was the `labelled` function. Since I was constantly presenting data to clinicians, it was important that the tables and figures I showed were clear and concise. I try to always eliminate the \"ugly\" variable names from my presentations and reports, as a rule... but while doing that as automatically as possible.\n\nIt was incredibly helpful to use `set_variable_labels()` from the `labelled` package to make the variable names ready for reporting. My favorite trick was to combine this function with the `to_title_case()` function from the `snakecase` package. The latter will take any variable of the format **`snake_case`** (i.e. all lowercase, with underscores between words), remove the underscores, and capitalize the first letter of each word -- just like a title.\n\nIf you use `to_title_case(names(.))` in the `.labels` global argument of the `set_variable_names()` function, it'll clean up most variables in an extremely intuitive and readable way. Then if there are variables (such as acronyms) that are still not labelled the way you'd prefer them to be, you can directly change them by listing the variable name and the character string you'd like it to say instead. We can do this for BMI, so it does not read \"Bmi\" when `to_title_case` transforms the label.\n\n\n\n```{.r .cell-code}\npatients %>% \n  # select vars of interest for tables\n  select(age, sex, bmi, current_smoker, immunosuppressed) %>%\n  # edit variable names using labelled package\n  labelled::set_variable_labels(\n    # change all variable labels to \"Title Case\"\n    .labels = snakecase::to_title_case(names(.)),\n    # change any extra variables that are not title case, like BMI\n    bmi = \"BMI\"\n    ) %>%\n  tbl_summary(\n    # don't show missing (unknown) values\n    missing = \"no\",\n    # make sure all numeric variables are reported as continuous\n    type = list(all_numeric() ~ \"continuous\")\n  ) %>%\n  # bold the labels\n  bold_labels()\n```\n\n```\nWarning: `all_numeric()` was deprecated in gtsummary 1.3.6.\nThe {tidyselect} and {dplyr} packages have implemented functions to select variables by class and type, and the {gtsummary} version is now deprecated.\n\nUse `where(is.numeric)` instead.\nThis warning is displayed once every 8 hours.\nCall `lifecycle::last_lifecycle_warnings()` to see where this warning was generated.\n```\n\n```\nWarning: The `fmt_missing()` function is deprecated and will soon be removed\n* Use the `sub_missing()` function instead\n```\n\n::: {.cell-output-display}\n```{=html}\n<div id=\"uwvdhggpza\" style=\"overflow-x:auto;overflow-y:auto;width:auto;height:auto;\">\n<style>html {\n  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Helvetica Neue', 'Fira Sans', 'Droid Sans', Arial, sans-serif;\n}\n\n#uwvdhggpza .gt_table {\n  display: table;\n  border-collapse: collapse;\n  margin-left: auto;\n  margin-right: auto;\n  color: #333333;\n  font-size: 16px;\n  font-weight: normal;\n  font-style: normal;\n  background-color: #FFFFFF;\n  width: auto;\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #A8A8A8;\n  border-right-style: none;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #A8A8A8;\n  border-left-style: none;\n  border-left-width: 2px;\n  border-left-color: #D3D3D3;\n}\n\n#uwvdhggpza .gt_heading {\n  background-color: #FFFFFF;\n  text-align: center;\n  border-bottom-color: #FFFFFF;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n}\n\n#uwvdhggpza .gt_title {\n  color: #333333;\n  font-size: 125%;\n  font-weight: initial;\n  padding-top: 4px;\n  padding-bottom: 4px;\n  padding-left: 5px;\n  padding-right: 5px;\n  border-bottom-color: #FFFFFF;\n  border-bottom-width: 0;\n}\n\n#uwvdhggpza .gt_subtitle {\n  color: #333333;\n  font-size: 85%;\n  font-weight: initial;\n  padding-top: 0;\n  padding-bottom: 6px;\n  padding-left: 5px;\n  padding-right: 5px;\n  border-top-color: #FFFFFF;\n  border-top-width: 0;\n}\n\n#uwvdhggpza .gt_bottom_border {\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n}\n\n#uwvdhggpza .gt_col_headings {\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n}\n\n#uwvdhggpza .gt_col_heading {\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: normal;\n  text-transform: inherit;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n  vertical-align: bottom;\n  padding-top: 5px;\n  padding-bottom: 6px;\n  padding-left: 5px;\n  padding-right: 5px;\n  overflow-x: hidden;\n}\n\n#uwvdhggpza .gt_column_spanner_outer {\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: normal;\n  text-transform: inherit;\n  padding-top: 0;\n  padding-bottom: 0;\n  padding-left: 4px;\n  padding-right: 4px;\n}\n\n#uwvdhggpza .gt_column_spanner_outer:first-child {\n  padding-left: 0;\n}\n\n#uwvdhggpza .gt_column_spanner_outer:last-child {\n  padding-right: 0;\n}\n\n#uwvdhggpza .gt_column_spanner {\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  vertical-align: bottom;\n  padding-top: 5px;\n  padding-bottom: 5px;\n  overflow-x: hidden;\n  display: inline-block;\n  width: 100%;\n}\n\n#uwvdhggpza .gt_group_heading {\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: initial;\n  text-transform: inherit;\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n  vertical-align: middle;\n}\n\n#uwvdhggpza .gt_empty_group_heading {\n  padding: 0.5px;\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: initial;\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  vertical-align: middle;\n}\n\n#uwvdhggpza .gt_from_md > :first-child {\n  margin-top: 0;\n}\n\n#uwvdhggpza .gt_from_md > :last-child {\n  margin-bottom: 0;\n}\n\n#uwvdhggpza .gt_row {\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n  margin: 10px;\n  border-top-style: solid;\n  border-top-width: 1px;\n  border-top-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n  vertical-align: middle;\n  overflow-x: hidden;\n}\n\n#uwvdhggpza .gt_stub {\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: initial;\n  text-transform: inherit;\n  border-right-style: solid;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n  padding-left: 5px;\n  padding-right: 5px;\n}\n\n#uwvdhggpza .gt_stub_row_group {\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: initial;\n  text-transform: inherit;\n  border-right-style: solid;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n  padding-left: 5px;\n  padding-right: 5px;\n  vertical-align: top;\n}\n\n#uwvdhggpza .gt_row_group_first td {\n  border-top-width: 2px;\n}\n\n#uwvdhggpza .gt_summary_row {\n  color: #333333;\n  background-color: #FFFFFF;\n  text-transform: inherit;\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n}\n\n#uwvdhggpza .gt_first_summary_row {\n  border-top-style: solid;\n  border-top-color: #D3D3D3;\n}\n\n#uwvdhggpza .gt_first_summary_row.thick {\n  border-top-width: 2px;\n}\n\n#uwvdhggpza .gt_last_summary_row {\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n}\n\n#uwvdhggpza .gt_grand_summary_row {\n  color: #333333;\n  background-color: #FFFFFF;\n  text-transform: inherit;\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n}\n\n#uwvdhggpza .gt_first_grand_summary_row {\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n  border-top-style: double;\n  border-top-width: 6px;\n  border-top-color: #D3D3D3;\n}\n\n#uwvdhggpza .gt_striped {\n  background-color: rgba(128, 128, 128, 0.05);\n}\n\n#uwvdhggpza .gt_table_body {\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n}\n\n#uwvdhggpza .gt_footnotes {\n  color: #333333;\n  background-color: #FFFFFF;\n  border-bottom-style: none;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 2px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n}\n\n#uwvdhggpza .gt_footnote {\n  margin: 0px;\n  font-size: 90%;\n  padding-left: 4px;\n  padding-right: 4px;\n  padding-left: 5px;\n  padding-right: 5px;\n}\n\n#uwvdhggpza .gt_sourcenotes {\n  color: #333333;\n  background-color: #FFFFFF;\n  border-bottom-style: none;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 2px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n}\n\n#uwvdhggpza .gt_sourcenote {\n  font-size: 90%;\n  padding-top: 4px;\n  padding-bottom: 4px;\n  padding-left: 5px;\n  padding-right: 5px;\n}\n\n#uwvdhggpza .gt_left {\n  text-align: left;\n}\n\n#uwvdhggpza .gt_center {\n  text-align: center;\n}\n\n#uwvdhggpza .gt_right {\n  text-align: right;\n  font-variant-numeric: tabular-nums;\n}\n\n#uwvdhggpza .gt_font_normal {\n  font-weight: normal;\n}\n\n#uwvdhggpza .gt_font_bold {\n  font-weight: bold;\n}\n\n#uwvdhggpza .gt_font_italic {\n  font-style: italic;\n}\n\n#uwvdhggpza .gt_super {\n  font-size: 65%;\n}\n\n#uwvdhggpza .gt_two_val_uncert {\n  display: inline-block;\n  line-height: 1em;\n  text-align: right;\n  font-size: 60%;\n  vertical-align: -0.25em;\n  margin-left: 0.1em;\n}\n\n#uwvdhggpza .gt_footnote_marks {\n  font-style: italic;\n  font-weight: normal;\n  font-size: 75%;\n  vertical-align: 0.4em;\n}\n\n#uwvdhggpza .gt_asterisk {\n  font-size: 100%;\n  vertical-align: 0;\n}\n\n#uwvdhggpza .gt_slash_mark {\n  font-size: 0.7em;\n  line-height: 0.7em;\n  vertical-align: 0.15em;\n}\n\n#uwvdhggpza .gt_fraction_numerator {\n  font-size: 0.6em;\n  line-height: 0.6em;\n  vertical-align: 0.45em;\n}\n\n#uwvdhggpza .gt_fraction_denominator {\n  font-size: 0.6em;\n  line-height: 0.6em;\n  vertical-align: -0.05em;\n}\n</style>\n<table class=\"gt_table\">\n  \n  <thead class=\"gt_col_headings\">\n    <tr>\n      <th class=\"gt_col_heading gt_columns_bottom_border gt_left\" rowspan=\"1\" colspan=\"1\"><strong>Characteristic</strong></th>\n      <th class=\"gt_col_heading gt_columns_bottom_border gt_center\" rowspan=\"1\" colspan=\"1\"><strong>N = 5</strong><sup class=\"gt_footnote_marks\">1</sup></th>\n    </tr>\n  </thead>\n  <tbody class=\"gt_table_body\">\n    <tr><td class=\"gt_row gt_left\" style=\"font-weight: bold;\">Age</td>\n<td class=\"gt_row gt_center\">61 (49, 64)</td></tr>\n    <tr><td class=\"gt_row gt_left\" style=\"font-weight: bold;\">Sex</td>\n<td class=\"gt_row gt_center\"></td></tr>\n    <tr><td class=\"gt_row gt_left\" style=\"text-align: left; text-indent: 10px;\">Female</td>\n<td class=\"gt_row gt_center\">2 (40%)</td></tr>\n    <tr><td class=\"gt_row gt_left\" style=\"text-align: left; text-indent: 10px;\">Male</td>\n<td class=\"gt_row gt_center\">3 (60%)</td></tr>\n    <tr><td class=\"gt_row gt_left\" style=\"font-weight: bold;\">BMI</td>\n<td class=\"gt_row gt_center\">27.3 (23.4, 30.8)</td></tr>\n    <tr><td class=\"gt_row gt_left\" style=\"font-weight: bold;\">Current Smoker</td>\n<td class=\"gt_row gt_center\">2 (40%)</td></tr>\n    <tr><td class=\"gt_row gt_left\" style=\"font-weight: bold;\">Immunosuppressed</td>\n<td class=\"gt_row gt_center\">3 (60%)</td></tr>\n  </tbody>\n  \n  <tfoot class=\"gt_footnotes\">\n    <tr>\n      <td class=\"gt_footnote\" colspan=\"2\"><sup class=\"gt_footnote_marks\">1</sup> Median (IQR); n (%)</td>\n    </tr>\n  </tfoot>\n</table>\n</div>\n```\n:::\n\n\nSo clean and readable, with such little effort! A few other lines of code I usually add to make the tables nicer with very little effort are `missing = \"no\"` to the main `tbl_summary()` argument, and `bold_labels()` after.\n\n# 3. `dplyr::filter()` + `stringr::str_detect()` + `tolower()`\n\nThis has been *such* a life saver when searching through very long-form COVID-19 data for a particular lab, vital sign, medication, or order of interest. I often don't know the exact word, much less capitalization, of the string I'm looking for in a data set, but this combination of functions really saves the day.\n\nHere we can use it to figure out the name of patients' absolute lymphocyte count labs. Of course we could just do something like:\n\n\n\n```{.r .cell-code}\nsort(unique(labs$lab_name))\n```\n\n[1] \"Absolute Lymphocyte Count\" \"C-Reactive Protein\"       \n[3] \"D-Dimer\"                   \"Lactate Dehydrogenase\"    \n[5] \"LYMPHOCYTE PERC\"           \"Platelet Count\"           \n\n\n\nBut in my actual data sets of upwards of 50 million rows, this would return thousands of results! I discovered the easiest way to find what I was looking for was to first convert the `lab_name` to all lowercase using `tolower(lab_name)`, and then search for strings using `str_detect()`, only keeping rows that matched using `filter()` and then looking at *those* unique values using `pull()`* and `unique()`.\n\n\n\n```{.r .cell-code}\nlabs %>%\n  filter(str_detect(tolower(lab_name), \"lymph\")) %>%\n  pull(lab_name) %>%\n  unique() \n```\n\n```\nfilter: removed 1,078 rows (66%), 545 rows remaining\n```\n\n[1] \"Absolute Lymphocyte Count\" \"LYMPHOCYTE PERC\"          \n\n\n\nAlthough you don't have to use pipes to do this, I often used those filtered rows for other exploratory data checks, such as looking at the units or distributions of the tests, so it was helpful to have it in the \"tidy\" format.\n\n*`pull()` is a somewhat lesser known function of `dplyr` that extracts a column as a dimensionless vector from a data frame, rather than `select`ing a single column, which `R` still treats as a data frame.\n\n# 4. `readr::parse_number()`\n\nThis is handy whenever I'm dealing with test results that can contain values above or below a detection range. Instead of using `as.numeric()` on a vector, I've switched to always using `readr`'s `parse_number()` function. This is because `as.numeric()` will turn values with meaningful information (such as \">1,000\") into `NA`.\n\nLet's look at this with the D-Dimer values in `patients_labs`. If you've been keeping up with any of the cytokine storm in COVID-19 headlines, you'll know that D-Dimers are often sky-high in severely ill COVID-19 patients. So high, that they're sometimes out of detectable ranges*!\n \n\n\n```{.r .cell-code}\npatient_labs %>%\n  filter(str_detect(tolower(lab_name), \"dimer\")) %>%\n  select(lab_name, lab_value) %>%\n  mutate(lab_value_numeric = as.numeric(lab_value),\n         lab_value_parsed_number = readr::parse_number(lab_value))\n```\n\n```\nfilter: removed 536 rows (85%), 94 rows remaining\n```\n\n```\nWarning in mask$eval_all_mutate(quo): NAs introduced by coercion\n```\n\n# A tibble: 94 √ó 4\n   lab_name lab_value lab_value_numeric lab_value_parsed_number\n   <chr>    <chr>                 <dbl>                   <dbl>\n 1 D-Dimer  642                     642                     642\n 2 D-Dimer  531                     531                     531\n 3 D-Dimer  674                     674                     674\n 4 D-Dimer  751                     751                     751\n 5 D-Dimer  436                     436                     436\n 6 D-Dimer  181                     181                     181\n 7 D-Dimer  107                     107                     107\n 8 D-Dimer  >1000                    NA                    1000\n 9 D-Dimer  251                     251                     251\n10 D-Dimer  148                     148                     148\n# ‚Ä¶ with 84 more rows\n\n\nWhen we use `as.numeric()` to switch the values from strings, we lose those out of range values. Those are our sickest patients, so if we continue with the analysis, we'll definitely bias our results. However, if we use `parse_number()` we can at least evaluate those patients conservatively, using the upper bound of the test detection range.\n\n*Detectable range is usually >55,000 ng/mL, but for the sake of demonstration, let's pretend it's >1,000 of the mystery units in my fake data set.\n\n# 5. `lubridate`'s `%within%` + `interval()` + `hours()`\n\nLast but not least is two beautiful functions from the `lubridate` package. If you ever find yourself working with time-stamped data, you should definitely check it out. I tried multiple functions and packages at the beginning of the outbreak, and in the end, nothing compared to `lubridate`, at least for my use-cases.\n\nThe `%within%` function allows you to determine whether a time value (stored in `R` as a `POSIXct` object) falls within a window of time. You can specify this window of time using the `interval()` function. If you have only the start or the end time of the window of interest, you can add or subtract using supplemental functions like `days()` or `hours()`. \n\nFor my COVID-19 research, the pulmonologists were often interested in snapshots of patients relative to a certain time in their disease course, for example, within the first 24 hours after intubation. The `lubridate` functions made it super easy to extract the labs, vital signs, or other information that happened relative to another date.\n\nHere's how we could use the aforementioned functions in the `patient_labs` dataset we made previously. We can extract all the labs relative to 24 hours after the hospital admission date.\n\n\n\n```{.r .cell-code}\nlibrary(lubridate)\n```\n\n```\n\nAttaching package: 'lubridate'\n```\n\n```\nThe following objects are masked from 'package:base':\n\n    date, intersect, setdiff, union\n```\n\n```{.r .cell-code}\npatient_labs %>%\n  filter(lab_time %within% interval(admit_dt, admit_dt + days(1)))\n```\n\n```\nfilter: removed 623 rows (99%), 7 rows remaining\n```\n\n# A tibble: 7 √ó 11\n     id admit_dt            death_or_discharge_dt   age sex    current‚Ä¶¬π immun‚Ä¶¬≤\n  <dbl> <dttm>              <dttm>                <dbl> <chr>  <chr>     <chr>  \n1   100 2020-03-21 00:10:00 2020-05-13 12:10:00      64 Male   Yes       No     \n2   104 2020-04-03 12:15:00 2020-04-29 18:34:00      25 Male   Yes       No     \n3   106 2020-03-28 12:22:00 2020-04-05 19:18:00      49 Female No        Yes    \n4   106 2020-03-28 12:22:00 2020-04-05 19:18:00      49 Female No        Yes    \n5   106 2020-03-28 12:22:00 2020-04-05 19:18:00      49 Female No        Yes    \n6   106 2020-03-28 12:22:00 2020-04-05 19:18:00      49 Female No        Yes    \n7   107 2020-04-10 18:15:00 2020-04-14 19:12:00      88 Male   No        Yes    \n# ‚Ä¶ with 4 more variables: bmi <dbl>, lab_time <dttm>, lab_name <chr>,\n#   lab_value <chr>, and abbreviated variable names ¬π‚Äãcurrent_smoker,\n#   ¬≤‚Äãimmunosuppressed\n\n\nPerfect! I could go on to informatively join this data to another using `tidylog`, make tables with clean labels using `tbl_summary()`, `set_variable_labels()`, and `to_title_case()`, find further labs of interest with `filter()`, `str_detect()`, and `tolower()`, and make the lab values numeric with `parse_number()`... the possibilities are endless!\n\nI hope you enjoyed a quick insight into the data side of COVID-19 research, and/or perhaps picked up some useful function combinations for your own applied work with `R`.\n\n\n\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}