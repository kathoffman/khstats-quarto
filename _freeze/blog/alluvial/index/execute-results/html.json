{
  "hash": "49e58cc241e9fd89316b2649bb315cbd",
  "result": {
    "markdown": "---\ntitle: \"Alluvial Plots (AKA Sankey Diagrams) for Time-Varying Data\"\nauthor: \"Katherine Hoffman\"\ndate: \"2023-01-02\"\ncategories: [programming]\nimage: \"image.png\"\ndraft: true\ndescription: \" \"\ntags: \n  - rstats\n  - alluvial plot\n  - sankey diagrams\n  - time varying data\n---\n\n```{=tex}\n\\usepackage{amsmath}\n\\DeclareMathOperator*{\\argmax}{arg\\,max}\n```\n\n\n\n\nAlluvial plots, or Sankey diagrams, can be used to show the movement of individual units across a single variable, such as time. This post will first explain how to use the [`ggalluvial`](https://cran.r-project.org/web/packages/ggalluvial/vignettes/ggalluvial.html#:~:text=The%20%7Bggalluvial%7D%20package%20is%20a,the%20feedback%20of%20many%20users.) package with a straightforward use-case: showing how an illness severity score changes in a population of critically ill patients by day.\n\n\n\n::: {.cell}\n\n:::\n\n\n\n\nThen, we will use the same package and ideas to walk through how to show data we typically use for survival analyses in an alluvial chart. I'll use `ggalluvial` to show the movement of the following complexities over time:\n\n- categorical, time-varying exposure\n- time-to-event outcome\n- competing event\n- loss to follow up\n\nThese plots can be organized to look similar to Kaplan Meier plots.\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-3-1.png){width=768}\n:::\n:::\n\n\n# Step 0: Load long-form data\n\nWe'll first read in the data set from my Github. This data is in **long-form**, meaning there is one row for every patient at every time point of the study. There are 3,300 patients in this data, and there are 14 time points, so 14 * 3,300 = 49,500 rows.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat_long <- read_csv(here::here(\"blog/alluvial/aki_death_status.csv\"))\ndat_long\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 49,500 × 3\n      id  time status                     \n   <dbl> <dbl> <chr>                      \n 1     1     0 Non-IMV supplemental oxygen\n 2     1     1 Non-IMV supplemental oxygen\n 3     1     2 Non-IMV supplemental oxygen\n 4     1     3 AKI                        \n 5     1     4 AKI                        \n 6     1     5 AKI                        \n 7     1     6 AKI                        \n 8     1     7 AKI                        \n 9     1     8 AKI                        \n10     1     9 AKI                        \n# ℹ 49,490 more rows\n```\n:::\n:::\n\n\nAt each `time` point, there is a column `status` which indicates whether the patient was still in the study, and if so, what their supplemental oxygen status, where categories are: \n\n- `\"No supplemental oxygen\"`\n\n- `\"Non-IMV supplemental oxygen\"`\n\n- `\"IMV\"`\n\nIf they are not in the study any longer, the status indicates whether it is because they \n\n- experienced the event of interest (`\"AKI\"`)\n- experienced a competing event, i.e. death (`\"Deceased\"`)\n- or they were informatively right-censored (`\"Discharged\"`).\n\n# Step 1: Create wide-form data\n\nI've started with the long-form data because I think(!) it is the most common form for an analyst to start with in their time-varying exposure and/or time-to-event data analysis. However, we actually need the data to be in **wide-form** to make it compatible for plotting using the `ggalluvial` package. Wide-form data means we want one row per patient (n=3,300) and one column per time point (k=14), and the values of each cell is the patient's status at that time point.\n\nWe will use the `pivot_wider()` function for this. Here are the breakdowns of the arguments we'll use in `pivot_wider()`. For more information, type `?pivot_wider()` into your `R` console.\n\n- `id_col = id` specifies that the `id` column uniquely identifies each observation (each patient)\n\n- `names_from = time` means the names of the new columns for each time point will come from the current `time` column\n\n- `names_prefix = \"time_\"` will relabel our new time columns to be {`time_1`, `time_2`, ..., `time_14`}\n\n- `values_from = status` indicates we want the values in the cells of our new data frame to be the values that are currently in the `status` column of our long-form data.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat_wide <-\n  dat_long |>\n  pivot_wider(id_cols = id,\n              names_from = time, \n              values_from = status,\n              names_prefix = \"time_\")\ndat_wide\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3,300 × 16\n      id time_0   time_1 time_2 time_3 time_4 time_5 time_6 time_7 time_8 time_9\n   <dbl> <chr>    <chr>  <chr>  <chr>  <chr>  <chr>  <chr>  <chr>  <chr>  <chr> \n 1     1 Non-IMV… Non-I… Non-I… AKI    AKI    AKI    AKI    AKI    AKI    AKI   \n 2     2 No supp… No su… Non-I… Non-I… Non-I… Non-I… Non-I… Non-I… Non-I… Non-I…\n 3     3 No supp… Disch… Disch… Disch… Disch… Disch… Disch… Disch… Disch… Disch…\n 4     4 Non-IMV… Non-I… Non-I… Non-I… Non-I… Non-I… Non-I… Non-I… Decea… Decea…\n 5     5 Non-IMV… Non-I… Non-I… Non-I… Non-I… No su… No su… No su… Disch… Disch…\n 6     6 Non-IMV… Non-I… AKI    AKI    AKI    AKI    AKI    AKI    AKI    AKI   \n 7     7 Non-IMV… No su… AKI    AKI    AKI    AKI    AKI    AKI    AKI    AKI   \n 8     8 Non-IMV… Non-I… Non-I… No su… No su… No su… Disch… Disch… Disch… Disch…\n 9     9 No supp… Non-I… Non-I… Non-I… Non-I… Non-I… Non-I… Disch… Disch… Disch…\n10    10 IMV      AKI    AKI    AKI    AKI    AKI    AKI    AKI    AKI    AKI   \n# ℹ 3,290 more rows\n# ℹ 5 more variables: time_10 <chr>, time_11 <chr>, time_12 <chr>,\n#   time_13 <chr>, time_14 <chr>\n```\n:::\n:::\n\n\n# Step 2: Create `ggalluvial`-compatible data\n\nThe next step after you have wide form data (with a status value for every observation and time point in your plot) is to get the data wrangled into the format that `ggalluvial` can handle for plotting.\n\nFirst, we need to get the number of observations (patients) which have the same \"flow\" or \"path\" across all the time points in our study. In other words, we want to know how many patients are on no supplemental oxygen for times 1-10 and are then discharged at time 11. We *also* want to know how many patients have an exposure of IMV their first day of the study, and then die the second day. There are hundreds of possible \"flows\" that could be observed across our different statuses and time points, and the way we get the N's for each flow that is to:\n\n1. `group_by` all the different columns indicating statuses per time point (here it is `time_1`, `time_2`, ..., `time_14`)\n\n2. `count()` across all those different `time_*` columns.\n\nTo implement this, I'm first going to create an objects that will make my code a bit more flexible. I'm going to create a vector denoting the `time_*` column names of my new wide-form data set. This will help me call the right variables to group very soon.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvars_to_group <- paste0(\"time_\", 0:max_time) \nvars_to_group\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"time_0\"  \"time_1\"  \"time_2\"  \"time_3\"  \"time_4\"  \"time_5\"  \"time_6\" \n [8] \"time_7\"  \"time_8\"  \"time_9\"  \"time_10\" \"time_11\" \"time_12\" \"time_13\"\n[15] \"time_14\"\n```\n:::\n:::\n\n\n## Step 2a: `group_by_at`\n\nNow, we want to first group by the columns that contain the status of each observation. For me, these are now in the vector `vars_to_group`. We will then use the dplyr function `group_by_at()` to group by **all** of those status-per-time columns. Let's look at the data after we do that. It shouldn't look any different from our `dat_wide`, except for the invisible \"GROUPS:\" of `time_1`, `time_2`, and so on.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat_wide |>\n  group_by_at(vars_to_group)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3,300 × 16\n# Groups:   time_0, time_1, time_2, time_3, time_4, time_5, time_6, time_7,\n#   time_8, time_9, time_10, time_11, time_12, time_13, time_14 [701]\n      id time_0   time_1 time_2 time_3 time_4 time_5 time_6 time_7 time_8 time_9\n   <dbl> <chr>    <chr>  <chr>  <chr>  <chr>  <chr>  <chr>  <chr>  <chr>  <chr> \n 1     1 Non-IMV… Non-I… Non-I… AKI    AKI    AKI    AKI    AKI    AKI    AKI   \n 2     2 No supp… No su… Non-I… Non-I… Non-I… Non-I… Non-I… Non-I… Non-I… Non-I…\n 3     3 No supp… Disch… Disch… Disch… Disch… Disch… Disch… Disch… Disch… Disch…\n 4     4 Non-IMV… Non-I… Non-I… Non-I… Non-I… Non-I… Non-I… Non-I… Decea… Decea…\n 5     5 Non-IMV… Non-I… Non-I… Non-I… Non-I… No su… No su… No su… Disch… Disch…\n 6     6 Non-IMV… Non-I… AKI    AKI    AKI    AKI    AKI    AKI    AKI    AKI   \n 7     7 Non-IMV… No su… AKI    AKI    AKI    AKI    AKI    AKI    AKI    AKI   \n 8     8 Non-IMV… Non-I… Non-I… No su… No su… No su… Disch… Disch… Disch… Disch…\n 9     9 No supp… Non-I… Non-I… Non-I… Non-I… Non-I… Non-I… Disch… Disch… Disch…\n10    10 IMV      AKI    AKI    AKI    AKI    AKI    AKI    AKI    AKI    AKI   \n# ℹ 3,290 more rows\n# ℹ 5 more variables: time_10 <chr>, time_11 <chr>, time_12 <chr>,\n#   time_13 <chr>, time_14 <chr>\n```\n:::\n:::\n\n\n## Step 2b: `count`\n\nOnce the data is properly grouped, `count()` will return the N's for each unique path or flow we observe in our data set.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat_wide |>\n  group_by_at(vars_to_group) |>\n  count() \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 701 × 16\n# Groups:   time_0, time_1, time_2, time_3, time_4, time_5, time_6, time_7,\n#   time_8, time_9, time_10, time_11, time_12, time_13, time_14 [701]\n   time_0 time_1 time_2 time_3 time_4 time_5 time_6 time_7 time_8 time_9 time_10\n   <chr>  <chr>  <chr>  <chr>  <chr>  <chr>  <chr>  <chr>  <chr>  <chr>  <chr>  \n 1 IMV    AKI    AKI    AKI    AKI    AKI    AKI    AKI    AKI    AKI    AKI    \n 2 IMV    Decea… Decea… Decea… Decea… Decea… Decea… Decea… Decea… Decea… Deceas…\n 3 IMV    IMV    AKI    AKI    AKI    AKI    AKI    AKI    AKI    AKI    AKI    \n 4 IMV    IMV    Decea… Decea… Decea… Decea… Decea… Decea… Decea… Decea… Deceas…\n 5 IMV    IMV    IMV    AKI    AKI    AKI    AKI    AKI    AKI    AKI    AKI    \n 6 IMV    IMV    IMV    IMV    AKI    AKI    AKI    AKI    AKI    AKI    AKI    \n 7 IMV    IMV    IMV    IMV    IMV    AKI    AKI    AKI    AKI    AKI    AKI    \n 8 IMV    IMV    IMV    IMV    IMV    Decea… Decea… Decea… Decea… Decea… Deceas…\n 9 IMV    IMV    IMV    IMV    IMV    IMV    AKI    AKI    AKI    AKI    AKI    \n10 IMV    IMV    IMV    IMV    IMV    IMV    IMV    AKI    AKI    AKI    AKI    \n# ℹ 691 more rows\n# ℹ 5 more variables: time_11 <chr>, time_12 <chr>, time_13 <chr>,\n#   time_14 <chr>, n <int>\n```\n:::\n:::\n\nIt's a bit hard to see what happened there, but a new column `n` was created with the N's in each pathway. We can see this better if we `select(n, everything())` (meaning select n, then all the other columns).\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat_wide |>\n  group_by_at(vars_to_group) |>\n  count() |>\n  select(n, everything())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 701 × 16\n# Groups:   time_0, time_1, time_2, time_3, time_4, time_5, time_6, time_7,\n#   time_8, time_9, time_10, time_11, time_12, time_13, time_14 [701]\n       n time_0 time_1   time_2 time_3 time_4 time_5 time_6 time_7 time_8 time_9\n   <int> <chr>  <chr>    <chr>  <chr>  <chr>  <chr>  <chr>  <chr>  <chr>  <chr> \n 1    45 IMV    AKI      AKI    AKI    AKI    AKI    AKI    AKI    AKI    AKI   \n 2     3 IMV    Deceased Decea… Decea… Decea… Decea… Decea… Decea… Decea… Decea…\n 3    18 IMV    IMV      AKI    AKI    AKI    AKI    AKI    AKI    AKI    AKI   \n 4     2 IMV    IMV      Decea… Decea… Decea… Decea… Decea… Decea… Decea… Decea…\n 5     5 IMV    IMV      IMV    AKI    AKI    AKI    AKI    AKI    AKI    AKI   \n 6     3 IMV    IMV      IMV    IMV    AKI    AKI    AKI    AKI    AKI    AKI   \n 7     3 IMV    IMV      IMV    IMV    IMV    AKI    AKI    AKI    AKI    AKI   \n 8     2 IMV    IMV      IMV    IMV    IMV    Decea… Decea… Decea… Decea… Decea…\n 9     2 IMV    IMV      IMV    IMV    IMV    IMV    AKI    AKI    AKI    AKI   \n10     1 IMV    IMV      IMV    IMV    IMV    IMV    IMV    AKI    AKI    AKI   \n# ℹ 691 more rows\n# ℹ 5 more variables: time_10 <chr>, time_11 <chr>, time_12 <chr>,\n#   time_13 <chr>, time_14 <chr>\n```\n:::\n:::\n\n\nSo, we can see that 45 patients have an exposure of Invasive Mechanical Ventilation (IMV) their index day of hospitalization, and then get Acute Kidney Injury (AKI), by their first full day of hospitalization.\n\n\n## Step 2c: `ggalluvial::to_lodes_form()`\n\nNow, we will use the `ggalluvial` package's function `to_lodes_form` to transfer all the potential paths into what is called \"lodes form.\"\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Titanic data in alluvia format\ntitanic_alluvia <- as.data.frame(Titanic)\nhead(titanic_alluvia)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  Class    Sex   Age Survived Freq\n1   1st   Male Child       No    0\n2   2nd   Male Child       No    0\n3   3rd   Male Child       No   35\n4  Crew   Male Child       No    0\n5   1st Female Child       No    0\n6   2nd Female Child       No    0\n```\n:::\n\n```{.r .cell-code}\nis_alluvia_form(titanic_alluvia,\n                weight = \"Freq\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\n# Titanic data in lodes format\ntitanic_lodes <- to_lodes_form(titanic_alluvia,\n                               key = \"x\", value = \"stratum\", id = \"alluvium\",\n                               axes = 1:4)\nhead(titanic_lodes)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  Freq alluvium     x stratum\n1    0        1 Class     1st\n2    0        2 Class     2nd\n3   35        3 Class     3rd\n4    0        4 Class    Crew\n5    0        5 Class     1st\n6    0        6 Class     2nd\n```\n:::\n\n```{.r .cell-code}\ntitanic_lodes2 <- to_lodes_form(titanic_alluvia,\n                                key = variable, value = value,\n                                id = cohort,\n                                1:3, diffuse = Class)\nhead(titanic_lodes2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  cohort Class Survived Freq variable value\n1      1   1st       No    0    Class   1st\n2      1   1st       No    0      Sex  Male\n3      1   1st       No    0      Age Child\n4      2   2nd       No    0    Class   2nd\n5      2   2nd       No    0      Sex  Male\n6      2   2nd       No    0      Age Child\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndat_wide |>\n  group_by_at(vars_to_group) |>\n  count() |>\n  to_lodes_form(key = \"time\", axes = 1:(length(vars_to_group)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 10,515 × 4\n       n alluvium time   stratum\n   <int>    <int> <fct>  <fct>  \n 1    45        1 time_0 IMV    \n 2     3        2 time_0 IMV    \n 3    18        3 time_0 IMV    \n 4     2        4 time_0 IMV    \n 5     5        5 time_0 IMV    \n 6     3        6 time_0 IMV    \n 7     3        7 time_0 IMV    \n 8     2        8 time_0 IMV    \n 9     2        9 time_0 IMV    \n10     1       10 time_0 IMV    \n# ℹ 10,505 more rows\n```\n:::\n:::\n\n\n\n## Step 2d: Changes x-axis and reorder status/stratum levels\n\nNow, we want the x-axis on our plot to show time in numbers, rather than `time_0`, `time_1`, etc., so we will use `parse_number()` to extract the number from our new column `time`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat_wide |>\n  group_by_at(vars_to_group) |>\n  count() |>\n  to_lodes_form(key = \"time\", axes = 1:(length(vars_to_group))) |>\n  mutate(time = factor(parse_number(as.character(time)))) # time column is a factor, so frist change to character, then parse_number, then change it back to a factor\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 10,515 × 4\n       n alluvium time  stratum\n   <int>    <int> <fct> <fct>  \n 1    45        1 0     IMV    \n 2     3        2 0     IMV    \n 3    18        3 0     IMV    \n 4     2        4 0     IMV    \n 5     5        5 0     IMV    \n 6     3        6 0     IMV    \n 7     3        7 0     IMV    \n 8     2        8 0     IMV    \n 9     2        9 0     IMV    \n10     1       10 0     IMV    \n# ℹ 10,505 more rows\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndat_alluvial <-\n dat_wide |>\n  group_by_at(vars_to_group) |>\n  count() |>\n  to_lodes_form(key = \"time\", axes = 1:(length(vars_to_group))) |>\n  mutate(time = factor(parse_number(as.character(time))), # time column is a factor, so frist change to character, then parse_number, then change it back to a factor\n        stratum = fct_relevel(stratum,\n                                      \"No supplemental oxygen\",\n                                      \"Non-IMV supplemental oxygen\",\n                                      \"IMV\", \n                                      \"AKI\",\n                                      \"Deceased\",\n                                      \"Discharged\"))\ndat_alluvial\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 10,515 × 4\n       n alluvium time  stratum\n   <int>    <int> <fct> <fct>  \n 1    45        1 0     IMV    \n 2     3        2 0     IMV    \n 3    18        3 0     IMV    \n 4     2        4 0     IMV    \n 5     5        5 0     IMV    \n 6     3        6 0     IMV    \n 7     3        7 0     IMV    \n 8     2        8 0     IMV    \n 9     2        9 0     IMV    \n10     1       10 0     IMV    \n# ℹ 10,505 more rows\n```\n:::\n:::\n\n\n# Step 3: Set up colors\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntype_colors <- c(\"#374E55\", # gray\n                 \"#79AF97\", # green\n                 \"#DF8F44\", #orange\n                  \"#00A1D5\", #bluea,\n                 \"#B24745\", #red\n                  \"#6A6599\" # purple\n                 ) \n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\np <- dat_alluvial |>\n  ggplot(\n    aes(x = time,\n        stratum = stratum, \n        col = stratum,\n        alluvium = alluvium,\n        y=n,\n        fill = stratum)\n  )\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\np <- p +\n  geom_flow() \np\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-16-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\np <- p +\n  geom_stratum() \n\np\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-17-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\np <- p +\n  scale_fill_manual(values = type_colors) \np\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-18-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\np <- p +\n  scale_color_manual(values = type_colors) \np\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-19-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\np <- p +\n  theme_classic() \np\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-20-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\np <- p +\n  scale_x_discrete(expand = c(0,0))\np\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-21-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\np <- p +\n  scale_y_continuous(expand = c(0,0)) \np\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-22-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\np <- p +\n  labs(x = \"Study Day\", y = \"Number of Patients\", title = \"Number of Patients per Exposure-Outcome Status by Day\",\n       fill = \"Status\", col = \"Status\") \np\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-23-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\np <- p +\n  theme(text=element_text(family=\"Times\", size=11),\n        legend.text = element_text(\n          size=9))\np\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-24-1.png){width=672}\n:::\n:::\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<!-- ## Step 0: Load the data -->\n\n<!-- ```{r} -->\n<!-- sofa_wide <- read_csv(here::here(\"blog/alluvial/pseudo_sofa_khstats.csv\")) |> -->\n<!--   mutate(across(starts_with(\"day\"), ~factor(.x, levels=c(\"Deceased\", 0:4,\"Missing\",\"Discharged\")))) |>   filter(score_type == \"pulmonary_sofa\") -->\n<!-- ``` -->\n\n<!-- The data structure we will use for each alluvial plot is **wide format**, i.e. one row per unit, and one column per time period. -->\n\n<!-- The `sofa_wide` data set shows this wide format data with one row for each of the six SOFA subscore per patient. We will subset this data for now to one subscore, the pulmonary SOFA score, and use this data to make our first plot. -->\n\n\n<!-- ```{r} -->\n<!-- glimpse(sofa_wide) -->\n<!-- head(sofa_wide) -->\n<!-- ``` -->\n\n<!-- ## Step 2 -->\n\n<!-- ```{r} -->\n<!-- sofa_wide |> -->\n<!--       group_by(day0, day1, day2, day3) |> -->\n<!--     count(.drop = F)  -->\n<!-- ``` -->\n\n<!-- # Step 3 -->\n\n\n<!-- ```{r} -->\n<!-- sofa_wide |> -->\n<!--     group_by(day0, day1, day2, day3) |> -->\n<!--     count(.drop = F) |> -->\n<!--     ungroup() |> -->\n<!--     to_lodes_form(key = \"day\", axes = 1:4) -->\n<!-- ``` -->\n\n<!-- ```{r} -->\n<!-- sofa_wide |> -->\n\n<!--     group_by(day0, day1, day2, day3) |> -->\n<!--     count(.drop = F) |> -->\n<!--     ungroup() |> -->\n<!--     to_lodes_form(key = \"day\", axes = 1:4)  |> -->\n<!--     mutate(day = case_when(day == \"day0\" ~ \"B\", -->\n<!--                            TRUE ~ as.character(parse_number(as.character(day)))), -->\n<!--            day = fct_relevel(day, \"B\")) -->\n<!-- ``` -->\n\n<!-- ```{r} -->\n<!-- sofa_alluv <- sofa_wide |> -->\n\n<!--     group_by(day0, day1, day2, day3) |> -->\n<!--     count(.drop = F) |> -->\n<!--     ungroup() |> -->\n<!--     to_lodes_form(key = \"day\", axes = 1:4)  |> -->\n<!--     mutate(day = case_when(day == \"day0\" ~ \"B\", -->\n<!--                            TRUE ~ as.character(parse_number(as.character(day)))), -->\n<!--            day = fct_relevel(day, \"B\")) -->\n<!-- ``` -->\n\n\n<!-- ```{r} -->\n<!-- p <- -->\n<!--   sofa_alluv |> -->\n<!--     ggplot(aes(x = day, -->\n<!--                y = n, -->\n<!--                stratum = stratum, -->\n<!--                alluvium = alluvium, -->\n<!--                fill = stratum)) -->\n<!-- p -->\n<!-- ``` -->\n\n<!-- ```{r} -->\n<!-- p <- p + geom_flow()  -->\n<!-- p -->\n<!-- ``` -->\n\n<!-- ```{r} -->\n<!-- p <- p + geom_stratum()  -->\n<!-- p -->\n<!-- ``` -->\n\n<!-- ```{r} -->\n<!-- p <- p + theme_classic()  -->\n<!-- p -->\n<!-- ``` -->\n\n<!-- ```{r} -->\n<!-- p <- p + coord_cartesian(xlim = c(.5,4.5), -->\n<!--                          ylim = c(0,100), -->\n<!--                          expand=F)  -->\n<!-- p -->\n<!-- ``` -->\n\n<!-- ```{r} -->\n<!-- p <- p + -->\n<!--   labs(x = \"Day\", -->\n<!--        y = \"Count\", -->\n<!--        fill = \"Subscore\",  -->\n<!--        title = \"Pulmonary SOFA Score by Day\") -->\n<!-- p -->\n<!-- ``` -->\n\n<!-- ```{r} -->\n<!-- my_pal <- ggsci::pal_nejm(\"default\", alpha = 0.6)(8) -->\n\n<!-- p <- p +   scale_fill_manual(values = my_pal, drop=F)  -->\n<!-- p -->\n<!-- ``` -->\n\n\n\n<!-- ```{r} -->\n<!-- p <- sofa_wide |> -->\n\n<!--     group_by(day0, day1, day2, day3) |> -->\n<!--     count(.drop = F) |> -->\n<!--     ungroup() |> -->\n<!--     to_lodes_form(key = \"day\", axes = 1:4)  |> -->\n<!--     mutate(day = case_when(day == \"day0\" ~ \"B\", -->\n<!--                            TRUE ~ as.character(parse_number(as.character(day)))), -->\n<!--            day = fct_relevel(day, \"B\")) |> -->\n<!--     ggplot(aes(x = day, y = n, -->\n<!--                stratum = stratum, -->\n<!--                alluvium = alluvium, -->\n<!--                fill = stratum)) + -->\n<!--     geom_flow() + -->\n<!--     geom_stratum() + -->\n<!--     theme_classic() + -->\n<!--     scale_x_discrete(expand = c(0.1,0.1)) + -->\n<!--     scale_fill_manual(values = my_pal, drop=F) + -->\n<!--     labs(x = \"Day\", y = \"Count\", -->\n<!--          fill = \"Subscore\", title = \"Pulmonary SOFA Score by Day\") -->\n\n<!-- p -->\n\n<!-- ``` -->\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}